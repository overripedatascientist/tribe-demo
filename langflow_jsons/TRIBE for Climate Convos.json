{
  "endpoint_name": null,
  "id": "d3a9f490-03e9-42b7-9a96-c184c0445231",
  "tags": null,
  "folder_id": "22988d38-8620-4782-9dcb-ba4ac2a69bce",
  "gradient": null,
  "data": {
    "nodes": [
      {
        "id": "ChatInput-nM66I",
        "type": "genericNode",
        "position": {
          "x": 1529.4374015642343,
          "y": 58.961738140033304
        },
        "data": {
          "description": "Get chat inputs from the Playground.",
          "display_name": "Chat Input",
          "id": "ChatInput-nM66I",
          "node": {
            "template": {
              "_type": "Component",
              "files": {
                "trace_as_metadata": true,
                "file_path": "",
                "fileTypes": [
                  "txt",
                  "md",
                  "mdx",
                  "csv",
                  "json",
                  "yaml",
                  "yml",
                  "xml",
                  "html",
                  "htm",
                  "pdf",
                  "docx",
                  "py",
                  "sh",
                  "sql",
                  "js",
                  "ts",
                  "tsx",
                  "jpg",
                  "jpeg",
                  "png",
                  "bmp",
                  "image"
                ],
                "list": true,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "files",
                "value": "",
                "display_name": "Files",
                "advanced": true,
                "dynamic": false,
                "info": "Files to be sent with the message.",
                "title_case": false,
                "type": "file",
                "_input_type": "FileInput"
              },
              "background_color": {
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "background_color",
                "value": "",
                "display_name": "Background Color",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The background color of the icon.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "chat_icon": {
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "chat_icon",
                "value": "",
                "display_name": "Icon",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The icon of the message.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langflow.base.data.utils import IMG_FILE_TYPES, TEXT_FILE_TYPES\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.io import DropdownInput, FileInput, MessageTextInput, MultilineInput, Output\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_NAME_USER, MESSAGE_SENDER_USER\n\n\nclass ChatInput(ChatComponent):\n    display_name = \"Chat Input\"\n    description = \"Get chat inputs from the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            value=\"\",\n            info=\"Message to be passed as input.\",\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_USER,\n            info=\"Type of sender.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_USER,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        FileInput(\n            name=\"files\",\n            display_name=\"Files\",\n            file_types=TEXT_FILE_TYPES + IMG_FILE_TYPES,\n            info=\"Files to be sent with the message.\",\n            advanced=True,\n            is_list=True,\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    def message_response(self) -> Message:\n        _background_color = self.background_color\n        _text_color = self.text_color\n        _icon = self.chat_icon\n        message = Message(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n            files=self.files,\n            properties={\"background_color\": _background_color, \"text_color\": _text_color, \"icon\": _icon},\n        )\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "input_value": {
                "tool_mode": false,
                "trace_as_input": true,
                "multiline": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "input_value",
                "value": "Based on the UN's guide to communicating on climate change, how might the Activist tribe react to messaging that gears towards:\n\n1. Use authoritative scientific information\n2. Convey the problem and the solutions\n3. Mobilize action\n\nPlease based your answer on the social media snippets provided in the context, which represent posts and comments from the Activists tribe",
                "display_name": "Text",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Message to be passed as input.",
                "title_case": false,
                "type": "str",
                "_input_type": "MultilineInput"
              },
              "sender": {
                "tool_mode": false,
                "trace_as_metadata": true,
                "options": [
                  "Machine",
                  "User"
                ],
                "combobox": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "sender",
                "value": "User",
                "display_name": "Sender Type",
                "advanced": true,
                "dynamic": false,
                "info": "Type of sender.",
                "title_case": false,
                "type": "str",
                "_input_type": "DropdownInput"
              },
              "sender_name": {
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "sender_name",
                "value": "User",
                "display_name": "Sender Name",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Name of the sender.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "session_id": {
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "session_id",
                "value": "",
                "display_name": "Session ID",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "should_store_message": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "should_store_message",
                "value": true,
                "display_name": "Store Messages",
                "advanced": true,
                "dynamic": false,
                "info": "Store the message in the history.",
                "title_case": false,
                "type": "bool",
                "_input_type": "BoolInput"
              },
              "text_color": {
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "text_color",
                "value": "",
                "display_name": "Text Color",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The text color of the name",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              }
            },
            "description": "Get chat inputs from the Playground.",
            "icon": "MessagesSquare",
            "base_classes": [
              "Message"
            ],
            "display_name": "Chat Input",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": true,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "message",
                "display_name": "Message",
                "method": "message_response",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "files",
              "background_color",
              "chat_icon",
              "text_color"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false,
            "lf_version": "1.1.1"
          },
          "type": "ChatInput"
        },
        "selected": false,
        "width": 320,
        "height": 234
      },
      {
        "id": "AstraDB-wNHGZ",
        "type": "genericNode",
        "position": {
          "x": 1850.6511200045366,
          "y": 444.3306196800248
        },
        "data": {
          "description": "Implementation of Vector Store using Astra DB with search capabilities",
          "display_name": "Astra DB",
          "edited": false,
          "id": "AstraDB-wNHGZ",
          "node": {
            "template": {
              "_type": "Component",
              "embedding": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "embedding",
                "value": "",
                "display_name": "Embedding or Astra Vectorize",
                "advanced": false,
                "input_types": [
                  "Embeddings",
                  "dict"
                ],
                "dynamic": false,
                "info": "Allows either an embedding model or an Astra Vectorize configuration.",
                "title_case": false,
                "type": "other",
                "_input_type": "HandleInput"
              },
              "ingest_data": {
                "tool_mode": false,
                "trace_as_metadata": true,
                "list": true,
                "trace_as_input": true,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "ingest_data",
                "value": "",
                "display_name": "Ingest Data",
                "advanced": false,
                "input_types": [
                  "Data"
                ],
                "dynamic": false,
                "info": "",
                "title_case": false,
                "type": "other",
                "_input_type": "DataInput"
              },
              "api_endpoint": {
                "load_from_db": false,
                "required": true,
                "placeholder": "",
                "show": true,
                "name": "api_endpoint",
                "value": "https://4423b0ba-2e75-4dcf-b2ad-d4b7e13218ca-us-east1.apps.astra.datastax.com",
                "display_name": "API Endpoint",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "API endpoint URL for the Astra DB service.",
                "title_case": false,
                "password": true,
                "type": "str",
                "_input_type": "SecretStrInput"
              },
              "batch_size": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "batch_size",
                "value": 25,
                "display_name": "Batch Size",
                "advanced": true,
                "dynamic": false,
                "info": "Optional number of data to process in a single batch.",
                "title_case": false,
                "type": "int",
                "_input_type": "IntInput",
                "load_from_db": false
              },
              "bulk_delete_concurrency": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "bulk_delete_concurrency",
                "value": "",
                "display_name": "Bulk Delete Concurrency",
                "advanced": true,
                "dynamic": false,
                "info": "Optional concurrency level for bulk delete operations.",
                "title_case": false,
                "type": "int",
                "_input_type": "IntInput"
              },
              "bulk_insert_batch_concurrency": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "bulk_insert_batch_concurrency",
                "value": "",
                "display_name": "Bulk Insert Batch Concurrency",
                "advanced": true,
                "dynamic": false,
                "info": "Optional concurrency level for bulk insert operations.",
                "title_case": false,
                "type": "int",
                "_input_type": "IntInput"
              },
              "bulk_insert_overwrite_concurrency": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "bulk_insert_overwrite_concurrency",
                "value": "",
                "display_name": "Bulk Insert Overwrite Concurrency",
                "advanced": true,
                "dynamic": false,
                "info": "Optional concurrency level for bulk insert operations that overwrite existing data.",
                "title_case": false,
                "type": "int",
                "_input_type": "IntInput"
              },
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from loguru import logger\r\nimport json\r\n\r\nfrom langflow.base.vectorstores.model import LCVectorStoreComponent, check_cached_vector_store\r\nfrom langflow.helpers import docs_to_data\r\nfrom langflow.inputs import FloatInput, MessageTextInput\r\nfrom langflow.io import (\r\n    BoolInput,\r\n    DataInput,\r\n    DropdownInput,\r\n    HandleInput,\r\n    IntInput,\r\n    MultilineInput,\r\n    SecretStrInput,\r\n    StrInput,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass AstraVectorStoreComponent(LCVectorStoreComponent):\r\n    display_name: str = \"Astra DB\"\r\n    description: str = \"Implementation of Vector Store using Astra DB with search capabilities\"\r\n    documentation: str = \"https://python.langchain.com/docs/integrations/vectorstores/astradb\"\r\n    name = \"AstraDB\"\r\n    icon: str = \"AstraDB\"\r\n\r\n    inputs = [\r\n        StrInput(\r\n            name=\"collection_name\",\r\n            display_name=\"Collection Name\",\r\n            info=\"The name of the collection within Astra DB where the vectors will be stored.\",\r\n            required=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"token\",\r\n            display_name=\"Astra DB Application Token\",\r\n            info=\"Authentication token for accessing Astra DB.\",\r\n            value=\"ASTRA_DB_APPLICATION_TOKEN\",\r\n            required=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_endpoint\",\r\n            display_name=\"API Endpoint\",\r\n            info=\"API endpoint URL for the Astra DB service.\",\r\n            value=\"ASTRA_DB_API_ENDPOINT\",\r\n            required=True,\r\n        ),\r\n        MultilineInput(\r\n            name=\"search_input\",\r\n            display_name=\"Search Input\",\r\n        ),\r\n        DataInput(\r\n            name=\"ingest_data\",\r\n            display_name=\"Ingest Data\",\r\n            is_list=True,\r\n        ),\r\n        StrInput(\r\n            name=\"namespace\",\r\n            display_name=\"Namespace\",\r\n            info=\"Optional namespace within Astra DB to use for the collection.\",\r\n            advanced=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"metric\",\r\n            display_name=\"Metric\",\r\n            info=\"Optional distance metric for vector comparisons in the vector store.\",\r\n            options=[\"cosine\", \"dot_product\", \"euclidean\"],\r\n            advanced=True,\r\n        ),\r\n        IntInput(\r\n            name=\"batch_size\",\r\n            display_name=\"Batch Size\",\r\n            info=\"Optional number of data to process in a single batch.\",\r\n            advanced=True,\r\n        ),\r\n        IntInput(\r\n            name=\"bulk_insert_batch_concurrency\",\r\n            display_name=\"Bulk Insert Batch Concurrency\",\r\n            info=\"Optional concurrency level for bulk insert operations.\",\r\n            advanced=True,\r\n        ),\r\n        IntInput(\r\n            name=\"bulk_insert_overwrite_concurrency\",\r\n            display_name=\"Bulk Insert Overwrite Concurrency\",\r\n            info=\"Optional concurrency level for bulk insert operations that overwrite existing data.\",\r\n            advanced=True,\r\n        ),\r\n        IntInput(\r\n            name=\"bulk_delete_concurrency\",\r\n            display_name=\"Bulk Delete Concurrency\",\r\n            info=\"Optional concurrency level for bulk delete operations.\",\r\n            advanced=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"setup_mode\",\r\n            display_name=\"Setup Mode\",\r\n            info=\"Configuration mode for setting up the vector store, with options like 'Sync', 'Async', or 'Off'.\",\r\n            options=[\"Sync\", \"Async\", \"Off\"],\r\n            advanced=True,\r\n            value=\"Sync\",\r\n        ),\r\n        BoolInput(\r\n            name=\"pre_delete_collection\",\r\n            display_name=\"Pre Delete Collection\",\r\n            info=\"Boolean flag to determine whether to delete the collection before creating a new one.\",\r\n            advanced=True,\r\n        ),\r\n        StrInput(\r\n            name=\"metadata_indexing_include\",\r\n            display_name=\"Metadata Indexing Include\",\r\n            info=\"Optional list of metadata fields to include in the indexing.\",\r\n            advanced=True,\r\n        ),\r\n        HandleInput(\r\n            name=\"embedding\",\r\n            display_name=\"Embedding or Astra Vectorize\",\r\n            input_types=[\"Embeddings\", \"dict\"],\r\n            info=\"Allows either an embedding model or an Astra Vectorize configuration.\",  # TODO: This should be optional, but need to refactor langchain-astradb first.\r\n        ),\r\n        StrInput(\r\n            name=\"metadata_indexing_exclude\",\r\n            display_name=\"Metadata Indexing Exclude\",\r\n            info=\"Optional list of metadata fields to exclude from the indexing.\",\r\n            advanced=True,\r\n        ),\r\n        StrInput(\r\n            name=\"collection_indexing_policy\",\r\n            display_name=\"Collection Indexing Policy\",\r\n            info=\"Optional dictionary defining the indexing policy for the collection.\",\r\n            advanced=True,\r\n        ),\r\n        IntInput(\r\n            name=\"number_of_results\",\r\n            display_name=\"Number of Results\",\r\n            info=\"Number of results to return.\",\r\n            advanced=True,\r\n            value=4,\r\n        ),\r\n        DropdownInput(\r\n            name=\"search_type\",\r\n            display_name=\"Search Type\",\r\n            info=\"Search type to use\",\r\n            options=[\"Similarity\", \"Similarity with score threshold\", \"MMR (Max Marginal Relevance)\"],\r\n            value=\"Similarity\",\r\n            advanced=True,\r\n        ),\r\n        FloatInput(\r\n            name=\"search_score_threshold\",\r\n            display_name=\"Search Score Threshold\",\r\n            info=\"Minimum similarity score threshold for search results. (when using 'Similarity with score threshold')\",\r\n            value=0,\r\n            advanced=True,\r\n        ),\r\n        # DictInput(\r\n        #     name=\"search_filter\",\r\n        #     display_name=\"Search Metadata Filter\",\r\n        #     info=\"Optional dictionary of filters to apply to the search query.\",\r\n        #     advanced=True,\r\n        #     is_list=True,\r\n        # ),\r\n        MessageTextInput(\r\n            name=\"search_filter\",\r\n            display_name=\"Search Metadata Filter\",\r\n            info=\"Optional JSON dictionary of filters to apply to the search query.\",\r\n        ),\r\n\r\n    ]\r\n\r\n    @check_cached_vector_store\r\n    def build_vector_store(self):\r\n        try:\r\n            from langchain_astradb import AstraDBVectorStore\r\n            from langchain_astradb.utils.astradb import SetupMode\r\n        except ImportError:\r\n            raise ImportError(\r\n                \"Could not import langchain Astra DB integration package. \"\r\n                \"Please install it with `pip install langchain-astradb`.\"\r\n            )\r\n\r\n        try:\r\n            if not self.setup_mode:\r\n                self.setup_mode = self._inputs[\"setup_mode\"].options[0]\r\n\r\n            setup_mode_value = SetupMode[self.setup_mode.upper()]\r\n        except KeyError:\r\n            raise ValueError(f\"Invalid setup mode: {self.setup_mode}\")\r\n\r\n        if not isinstance(self.embedding, dict):\r\n            embedding_dict = {\"embedding\": self.embedding}\r\n        else:\r\n            from astrapy.info import CollectionVectorServiceOptions\r\n\r\n            dict_options = self.embedding.get(\"collection_vector_service_options\", {})\r\n            dict_options[\"authentication\"] = {\r\n                k: v for k, v in dict_options.get(\"authentication\", {}).items() if k and v\r\n            }\r\n            dict_options[\"parameters\"] = {k: v for k, v in dict_options.get(\"parameters\", {}).items() if k and v}\r\n            embedding_dict = {\r\n                \"collection_vector_service_options\": CollectionVectorServiceOptions.from_dict(dict_options)\r\n            }\r\n            collection_embedding_api_key = self.embedding.get(\"collection_embedding_api_key\")\r\n            if collection_embedding_api_key:\r\n                embedding_dict[\"collection_embedding_api_key\"] = collection_embedding_api_key\r\n\r\n        vector_store_kwargs = {\r\n            **embedding_dict,\r\n            \"collection_name\": self.collection_name,\r\n            \"token\": self.token,\r\n            \"api_endpoint\": self.api_endpoint,\r\n            \"namespace\": self.namespace or None,\r\n            \"metric\": self.metric or None,\r\n            \"batch_size\": self.batch_size or None,\r\n            \"bulk_insert_batch_concurrency\": self.bulk_insert_batch_concurrency or None,\r\n            \"bulk_insert_overwrite_concurrency\": self.bulk_insert_overwrite_concurrency or None,\r\n            \"bulk_delete_concurrency\": self.bulk_delete_concurrency or None,\r\n            \"setup_mode\": setup_mode_value,\r\n            \"pre_delete_collection\": self.pre_delete_collection or False,\r\n        }\r\n\r\n        if self.metadata_indexing_include:\r\n            vector_store_kwargs[\"metadata_indexing_include\"] = self.metadata_indexing_include\r\n        elif self.metadata_indexing_exclude:\r\n            vector_store_kwargs[\"metadata_indexing_exclude\"] = self.metadata_indexing_exclude\r\n        elif self.collection_indexing_policy:\r\n            vector_store_kwargs[\"collection_indexing_policy\"] = self.collection_indexing_policy\r\n\r\n        try:\r\n            vector_store = AstraDBVectorStore(**vector_store_kwargs)\r\n        except Exception as e:\r\n            raise ValueError(f\"Error initializing AstraDBVectorStore: {str(e)}\") from e\r\n\r\n        self._add_documents_to_vector_store(vector_store)\r\n        return vector_store\r\n\r\n    def _add_documents_to_vector_store(self, vector_store):\r\n        documents = []\r\n        for _input in self.ingest_data or []:\r\n            if isinstance(_input, Data):\r\n                documents.append(_input.to_lc_document())\r\n            else:\r\n                raise ValueError(\"Vector Store Inputs must be Data objects.\")\r\n\r\n        if documents:\r\n            logger.debug(f\"Adding {len(documents)} documents to the Vector Store.\")\r\n            try:\r\n                vector_store.add_documents(documents)\r\n            except Exception as e:\r\n                raise ValueError(f\"Error adding documents to AstraDBVectorStore: {str(e)}\") from e\r\n        else:\r\n            logger.debug(\"No documents to add to the Vector Store.\")\r\n\r\n    def _map_search_type(self):\r\n        if self.search_type == \"Similarity with score threshold\":\r\n            return \"similarity_score_threshold\"\r\n        elif self.search_type == \"MMR (Max Marginal Relevance)\":\r\n            return \"mmr\"\r\n        else:\r\n            return \"similarity\"\r\n\r\n    def _build_search_args(self):\r\n        args = {\r\n            \"k\": self.number_of_results,\r\n            \"score_threshold\": self.search_score_threshold,\r\n        }\r\n\r\n        filter_dict = None\r\n        if self.search_filter:\r\n            try:\r\n                filter_list = json.loads(self.search_filter)\r\n                logger.info(f\"Filter list supplied: {filter_list}\")\r\n\r\n                if isinstance(filter_list, list):\r\n                    filter_conditions = []\r\n                    operator_map = {\r\n                        \"eq\": None,  # For equality, assign value directly\r\n                        \"neq\": \"$ne\",\r\n                        \"gt\": \"$gt\",\r\n                        \"gte\": \"$gte\",\r\n                        \"lt\": \"$lt\",\r\n                        \"lte\": \"$lte\",\r\n                        # Add more operators as needed\r\n                    }\r\n                    for item in filter_list:\r\n                        if isinstance(item, dict):\r\n                            field = item.get('field')\r\n                            operator = item.get('operator')\r\n                            value = item.get('value')\r\n                            if field and operator and value is not None:\r\n                                mapped_operator = operator_map.get(operator)\r\n                                if mapped_operator:\r\n                                    # For operators like 'gte', 'lte', etc.\r\n                                    condition = {field: {mapped_operator: value}}\r\n                                else:\r\n                                    # For equality ('eq')\r\n                                    condition = {field: value}\r\n                                filter_conditions.append(condition)\r\n                    if filter_conditions:\r\n                        if len(filter_conditions) == 1:\r\n                            filter_dict = filter_conditions[0]\r\n                        else:\r\n                            filter_dict = {\"$and\": filter_conditions}\r\n                else:\r\n                    logger.warning(\"Invalid search filter format. Expected a list of conditions.\")\r\n            except json.JSONDecodeError:\r\n                logger.warning(\"Invalid JSON format for search filter.\")\r\n            except Exception as e:\r\n                logger.error(f\"Error processing search filter: {str(e)}\")\r\n\r\n        if filter_dict:\r\n            args[\"filter\"] = filter_dict\r\n\r\n        return args\r\n\r\n    def search_documents(self) -> list[Data]:\r\n        vector_store = self.build_vector_store()\r\n\r\n        logger.debug(f\"Search input: {self.search_input}\")\r\n        logger.debug(f\"Search type: {self.search_type}\")\r\n        logger.debug(f\"Number of results: {self.number_of_results}\")\r\n\r\n        if self.search_input and isinstance(self.search_input, str) and self.search_input.strip():\r\n            try:\r\n                search_type = self._map_search_type()\r\n                search_args = self._build_search_args()\r\n                filter_dict = search_args.get(\"filter\")\r\n                k = search_args.get(\"k\", self.number_of_results)\r\n                score_threshold = search_args.get(\"score_threshold\")\r\n\r\n                if search_type == \"similarity_score_threshold\":\r\n                    docs_and_scores = vector_store.similarity_search_with_relevance_scores(\r\n                        query=self.search_input,\r\n                        k=k,\r\n                        filter=filter_dict,\r\n                        score_threshold=score_threshold\r\n                    )\r\n                    # Extract documents\r\n                    docs = [doc for doc, score in docs_and_scores]\r\n                elif search_type == \"similarity\":\r\n                    docs_and_scores = vector_store.similarity_search_with_relevance_scores(\r\n                        query=self.search_input,\r\n                        k=k,\r\n                        filter=filter_dict\r\n                    )\r\n                    # Extract documents\r\n                    docs = [doc for doc, score in docs_and_scores]\r\n                elif search_type == \"mmr\":\r\n                    docs = vector_store.max_marginal_relevance_search(\r\n                        query=self.search_input,\r\n                        k=k,\r\n                        filter=filter_dict\r\n                    )\r\n                    # No need to extract, already a list of Documents\r\n                else:\r\n                    raise ValueError(f\"Unknown search_type: {search_type}\")\r\n\r\n            except Exception as e:\r\n                raise ValueError(f\"Error performing search in AstraDBVectorStore: {str(e)}\") from e\r\n\r\n            logger.debug(f\"Retrieved documents: {len(docs)}\")\r\n\r\n            data = docs_to_data(docs)\r\n            logger.debug(f\"Converted documents to data: {len(data)}\")\r\n            self.status = data\r\n            return data\r\n        else:\r\n            logger.debug(\"No search input provided. Skipping search.\")\r\n            return []\r\n\r\n    def get_retriever_kwargs(self):\r\n        search_args = self._build_search_args()\r\n        return {\r\n            \"search_type\": self._map_search_type(),\r\n            \"search_kwargs\": search_args,\r\n        }\r\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "collection_indexing_policy": {
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "collection_indexing_policy",
                "value": "",
                "display_name": "Collection Indexing Policy",
                "advanced": true,
                "dynamic": false,
                "info": "Optional dictionary defining the indexing policy for the collection.",
                "title_case": false,
                "type": "str",
                "_input_type": "StrInput"
              },
              "collection_name": {
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": true,
                "placeholder": "",
                "show": true,
                "name": "collection_name",
                "value": "climate_change",
                "display_name": "Collection Name",
                "advanced": false,
                "dynamic": false,
                "info": "The name of the collection within Astra DB where the vectors will be stored.",
                "title_case": false,
                "type": "str",
                "_input_type": "StrInput"
              },
              "metadata_indexing_exclude": {
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "metadata_indexing_exclude",
                "value": "",
                "display_name": "Metadata Indexing Exclude",
                "advanced": true,
                "dynamic": false,
                "info": "Optional list of metadata fields to exclude from the indexing.",
                "title_case": false,
                "type": "str",
                "_input_type": "StrInput"
              },
              "metadata_indexing_include": {
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "metadata_indexing_include",
                "value": "",
                "display_name": "Metadata Indexing Include",
                "advanced": true,
                "dynamic": false,
                "info": "Optional list of metadata fields to include in the indexing.",
                "title_case": false,
                "type": "str",
                "_input_type": "StrInput"
              },
              "metric": {
                "tool_mode": false,
                "trace_as_metadata": true,
                "options": [
                  "cosine",
                  "dot_product",
                  "euclidean"
                ],
                "combobox": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "metric",
                "value": "cosine",
                "display_name": "Metric",
                "advanced": true,
                "dynamic": false,
                "info": "Optional distance metric for vector comparisons in the vector store.",
                "title_case": false,
                "type": "str",
                "_input_type": "DropdownInput",
                "load_from_db": false
              },
              "namespace": {
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "namespace",
                "value": "",
                "display_name": "Namespace",
                "advanced": true,
                "dynamic": false,
                "info": "Optional namespace within Astra DB to use for the collection.",
                "title_case": false,
                "type": "str",
                "_input_type": "StrInput"
              },
              "number_of_results": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "number_of_results",
                "value": 25,
                "display_name": "Number of Results",
                "advanced": true,
                "dynamic": false,
                "info": "Number of results to return.",
                "title_case": false,
                "type": "int",
                "_input_type": "IntInput",
                "load_from_db": false
              },
              "pre_delete_collection": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "pre_delete_collection",
                "value": false,
                "display_name": "Pre Delete Collection",
                "advanced": true,
                "dynamic": false,
                "info": "Boolean flag to determine whether to delete the collection before creating a new one.",
                "title_case": false,
                "type": "bool",
                "_input_type": "BoolInput"
              },
              "search_filter": {
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "search_filter",
                "value": "",
                "display_name": "Search Metadata Filter",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Optional JSON dictionary of filters to apply to the search query.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "search_input": {
                "tool_mode": false,
                "trace_as_input": true,
                "multiline": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "search_input",
                "value": "",
                "display_name": "Search Input",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "",
                "title_case": false,
                "type": "str",
                "_input_type": "MultilineInput"
              },
              "search_score_threshold": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "search_score_threshold",
                "value": "0.5",
                "display_name": "Search Score Threshold",
                "advanced": true,
                "dynamic": false,
                "info": "Minimum similarity score threshold for search results. (when using 'Similarity with score threshold')",
                "title_case": false,
                "type": "float",
                "_input_type": "FloatInput",
                "load_from_db": false
              },
              "search_type": {
                "tool_mode": false,
                "trace_as_metadata": true,
                "options": [
                  "Similarity",
                  "Similarity with score threshold",
                  "MMR (Max Marginal Relevance)"
                ],
                "combobox": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "search_type",
                "value": "Similarity with score threshold",
                "display_name": "Search Type",
                "advanced": true,
                "dynamic": false,
                "info": "Search type to use",
                "title_case": false,
                "type": "str",
                "_input_type": "DropdownInput",
                "load_from_db": false
              },
              "setup_mode": {
                "tool_mode": false,
                "trace_as_metadata": true,
                "options": [
                  "Sync",
                  "Async",
                  "Off"
                ],
                "combobox": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "setup_mode",
                "value": "Sync",
                "display_name": "Setup Mode",
                "advanced": true,
                "dynamic": false,
                "info": "Configuration mode for setting up the vector store, with options like 'Sync', 'Async', or 'Off'.",
                "title_case": false,
                "type": "str",
                "_input_type": "DropdownInput"
              },
              "token": {
                "load_from_db": true,
                "required": true,
                "placeholder": "",
                "show": true,
                "name": "token",
                "value": "ASTRA_DB_APPLICATION_TOKEN",
                "display_name": "Astra DB Application Token",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Authentication token for accessing Astra DB.",
                "title_case": false,
                "password": true,
                "type": "str",
                "_input_type": "SecretStrInput"
              }
            },
            "description": "Implementation of Vector Store using Astra DB with search capabilities",
            "icon": "AstraDB",
            "base_classes": [
              "Data",
              "Retriever"
            ],
            "display_name": "Astra DB",
            "documentation": "https://python.langchain.com/docs/integrations/vectorstores/astradb",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": true,
            "outputs": [
              {
                "types": [
                  "Retriever"
                ],
                "selected": "Retriever",
                "name": "base_retriever",
                "display_name": "Retriever",
                "method": "build_base_retriever",
                "value": "__UNDEFINED__",
                "cache": true,
                "required_inputs": []
              },
              {
                "types": [
                  "Data"
                ],
                "selected": "Data",
                "name": "search_results",
                "display_name": "Search Results",
                "method": "search_documents",
                "value": "__UNDEFINED__",
                "cache": true,
                "required_inputs": [
                  "api_endpoint",
                  "collection_name",
                  "token"
                ]
              }
            ],
            "field_order": [
              "collection_name",
              "token",
              "api_endpoint",
              "search_input",
              "ingest_data",
              "namespace",
              "metric",
              "batch_size",
              "bulk_insert_batch_concurrency",
              "bulk_insert_overwrite_concurrency",
              "bulk_delete_concurrency",
              "setup_mode",
              "pre_delete_collection",
              "metadata_indexing_include",
              "embedding",
              "metadata_indexing_exclude",
              "collection_indexing_policy",
              "number_of_results",
              "search_type",
              "search_score_threshold",
              "search_filter"
            ],
            "beta": false,
            "legacy": false,
            "edited": true,
            "metadata": {},
            "tool_mode": false,
            "lf_version": "1.1.1"
          },
          "type": "AstraDB"
        },
        "selected": false,
        "width": 320,
        "height": 747,
        "dragging": false
      },
      {
        "id": "ParseData-obnZv",
        "type": "genericNode",
        "position": {
          "x": 2824.786095481204,
          "y": 321.0234565523459
        },
        "data": {
          "description": "Convert Data into plain text following a specified template.",
          "display_name": "Parse Data",
          "id": "ParseData-obnZv",
          "node": {
            "template": {
              "_type": "Component",
              "data": {
                "tool_mode": false,
                "trace_as_metadata": true,
                "list": false,
                "trace_as_input": true,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "data",
                "value": "",
                "display_name": "Data",
                "advanced": false,
                "input_types": [
                  "Data"
                ],
                "dynamic": false,
                "info": "The data to convert to text.",
                "title_case": false,
                "type": "other",
                "_input_type": "DataInput"
              },
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langflow.custom import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.io import DataInput, MultilineInput, Output, StrInput\nfrom langflow.schema.message import Message\n\n\nclass ParseDataComponent(Component):\n    display_name = \"Parse Data\"\n    description = \"Convert Data into plain text following a specified template.\"\n    icon = \"braces\"\n    name = \"ParseData\"\n\n    inputs = [\n        DataInput(name=\"data\", display_name=\"Data\", info=\"The data to convert to text.\"),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. \"\n            \"It can contain the keys {text}, {data} or any other key in the Data.\",\n            value=\"{text}\",\n        ),\n        StrInput(name=\"sep\", display_name=\"Separator\", advanced=True, value=\"\\n\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Text\", name=\"text\", method=\"parse_data\"),\n    ]\n\n    def parse_data(self) -> Message:\n        data = self.data if isinstance(self.data, list) else [self.data]\n        template = self.template\n\n        result_string = data_to_text(template, data, sep=self.sep)\n        self.status = result_string\n        return Message(text=result_string)\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "sep": {
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "sep",
                "value": "\n",
                "display_name": "Separator",
                "advanced": true,
                "dynamic": false,
                "info": "",
                "title_case": false,
                "type": "str",
                "_input_type": "StrInput"
              },
              "template": {
                "tool_mode": false,
                "trace_as_input": true,
                "multiline": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "template",
                "value": "By a {user_age_group_years} {user_gender} user in {user_country} on {platform}:\\n\n{text}\\n\n(stats: {likes_count} likes, {shares_count} shares, created at: {create_time})\\n\n------------------------------------------\\n",
                "display_name": "Template",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.",
                "title_case": false,
                "type": "str",
                "_input_type": "MultilineInput"
              }
            },
            "description": "Convert Data into plain text following a specified template.",
            "icon": "braces",
            "base_classes": [
              "Message"
            ],
            "display_name": "Parse Data",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": true,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "text",
                "display_name": "Text",
                "method": "parse_data",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "data",
              "template",
              "sep"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false,
            "lf_version": "1.1.1"
          },
          "type": "ParseData"
        },
        "selected": false,
        "width": 320,
        "height": 302
      },
      {
        "id": "ChatOutput-plpD3",
        "type": "genericNode",
        "position": {
          "x": 5128.006747135585,
          "y": 1216.8170931497473
        },
        "data": {
          "description": "Display a chat message in the Playground.",
          "display_name": "Chat Output",
          "id": "ChatOutput-plpD3",
          "node": {
            "template": {
              "_type": "Component",
              "background_color": {
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "background_color",
                "value": "",
                "display_name": "Background Color",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The background color of the icon.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "chat_icon": {
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "chat_icon",
                "value": "",
                "display_name": "Icon",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The icon of the message.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.io import DropdownInput, MessageInput, MessageTextInput, Output\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_NAME_AI, MESSAGE_SENDER_USER\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n\n    inputs = [\n        MessageInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, _id: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if _id:\n            source_dict[\"id\"] = _id\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            source_dict[\"source\"] = source\n        return Source(**source_dict)\n\n    def message_response(self) -> Message:\n        _source, _icon, _display_name, _source_id = self.get_properties_from_source_component()\n        _background_color = self.background_color\n        _text_color = self.text_color\n        if self.chat_icon:\n            _icon = self.chat_icon\n        message = self.input_value if isinstance(self.input_value, Message) else Message(text=self.input_value)\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(_source_id, _display_name, _source)\n        message.properties.icon = _icon\n        message.properties.background_color = _background_color\n        message.properties.text_color = _text_color\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "data_template": {
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "data_template",
                "value": "{text}",
                "display_name": "Data Template",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "input_value": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "input_value",
                "value": "",
                "display_name": "Text",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Message to be passed as output.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageInput"
              },
              "sender": {
                "tool_mode": false,
                "trace_as_metadata": true,
                "options": [
                  "Machine",
                  "User"
                ],
                "combobox": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "sender",
                "value": "Machine",
                "display_name": "Sender Type",
                "advanced": true,
                "dynamic": false,
                "info": "Type of sender.",
                "title_case": false,
                "type": "str",
                "_input_type": "DropdownInput"
              },
              "sender_name": {
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "sender_name",
                "value": "AI",
                "display_name": "Sender Name",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Name of the sender.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "session_id": {
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "session_id",
                "value": "",
                "display_name": "Session ID",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "should_store_message": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "should_store_message",
                "value": true,
                "display_name": "Store Messages",
                "advanced": true,
                "dynamic": false,
                "info": "Store the message in the history.",
                "title_case": false,
                "type": "bool",
                "_input_type": "BoolInput"
              },
              "text_color": {
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "text_color",
                "value": "",
                "display_name": "Text Color",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The text color of the name",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              }
            },
            "description": "Display a chat message in the Playground.",
            "icon": "MessagesSquare",
            "base_classes": [
              "Message"
            ],
            "display_name": "Chat Output",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "message",
                "display_name": "Message",
                "method": "message_response",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template",
              "background_color",
              "chat_icon",
              "text_color"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
          },
          "type": "ChatOutput"
        },
        "selected": false,
        "width": 320,
        "height": 234,
        "dragging": false
      },
      {
        "id": "AnthropicModel-FvFsG",
        "type": "genericNode",
        "position": {
          "x": 3868.6350550916895,
          "y": 542.2757923373767
        },
        "data": {
          "type": "AnthropicModel",
          "node": {
            "template": {
              "_type": "Component",
              "output_parser": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "output_parser",
                "value": "",
                "display_name": "Output Parser",
                "advanced": true,
                "input_types": [
                  "OutputParser"
                ],
                "dynamic": false,
                "info": "The parser to use to parse the output of the model",
                "title_case": false,
                "type": "other",
                "_input_type": "HandleInput"
              },
              "anthropic_api_key": {
                "load_from_db": true,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "anthropic_api_key",
                "value": "ANTHROPIC_API_KEY",
                "display_name": "Anthropic API Key",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Your Anthropic API key.",
                "title_case": false,
                "password": true,
                "type": "str",
                "_input_type": "SecretStrInput"
              },
              "anthropic_api_url": {
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "anthropic_api_url",
                "value": "",
                "display_name": "Anthropic API URL",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Endpoint of the Anthropic API. Defaults to 'https://api.anthropic.com' if not specified.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from pydantic.v1 import SecretStr\n\nfrom langflow.base.models.anthropic_constants import ANTHROPIC_MODELS\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import DropdownInput, FloatInput, IntInput, MessageTextInput, SecretStrInput\n\n\nclass AnthropicModelComponent(LCModelComponent):\n    display_name = \"Anthropic\"\n    description = \"Generate text using Anthropic Chat&Completion LLMs with prefill support.\"\n    icon = \"Anthropic\"\n    name = \"AnthropicModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            value=4096,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n        ),\n        DropdownInput(\n            name=\"model\",\n            display_name=\"Model Name\",\n            options=ANTHROPIC_MODELS,\n            info=\"https://python.langchain.com/docs/integrations/chat/anthropic\",\n            value=\"claude-3-5-sonnet-latest\",\n        ),\n        SecretStrInput(name=\"anthropic_api_key\", display_name=\"Anthropic API Key\", info=\"Your Anthropic API key.\"),\n        FloatInput(name=\"temperature\", display_name=\"Temperature\", value=0.1),\n        MessageTextInput(\n            name=\"anthropic_api_url\",\n            display_name=\"Anthropic API URL\",\n            advanced=True,\n            info=\"Endpoint of the Anthropic API. Defaults to 'https://api.anthropic.com' if not specified.\",\n        ),\n        MessageTextInput(\n            name=\"prefill\", display_name=\"Prefill\", info=\"Prefill text to guide the model's response.\", advanced=True\n        ),\n        HandleInput(\n            name=\"output_parser\",\n            display_name=\"Output Parser\",\n            info=\"The parser to use to parse the output of the model\",\n            advanced=True,\n            input_types=[\"OutputParser\"],\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        try:\n            from langchain_anthropic.chat_models import ChatAnthropic\n        except ImportError as e:\n            msg = \"langchain_anthropic is not installed. Please install it with `pip install langchain_anthropic`.\"\n            raise ImportError(msg) from e\n        model = self.model\n        anthropic_api_key = self.anthropic_api_key\n        max_tokens = self.max_tokens\n        temperature = self.temperature\n        anthropic_api_url = self.anthropic_api_url or \"https://api.anthropic.com\"\n\n        try:\n            output = ChatAnthropic(\n                model=model,\n                anthropic_api_key=(SecretStr(anthropic_api_key).get_secret_value() if anthropic_api_key else None),\n                max_tokens_to_sample=max_tokens,\n                temperature=temperature,\n                anthropic_api_url=anthropic_api_url,\n                streaming=self.stream,\n            )\n        except Exception as e:\n            msg = \"Could not connect to Anthropic API.\"\n            raise ValueError(msg) from e\n\n        return output\n\n    def _get_exception_message(self, exception: Exception) -> str | None:\n        \"\"\"Get a message from an Anthropic exception.\n\n        Args:\n            exception (Exception): The exception to get the message from.\n\n        Returns:\n            str: The message from the exception.\n        \"\"\"\n        try:\n            from anthropic import BadRequestError\n        except ImportError:\n            return None\n        if isinstance(exception, BadRequestError):\n            message = exception.body.get(\"error\", {}).get(\"message\")\n            if message:\n                return message\n        return None\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "input_value": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "input_value",
                "value": "",
                "display_name": "Input",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageInput"
              },
              "max_tokens": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "max_tokens",
                "value": 4096,
                "display_name": "Max Tokens",
                "advanced": true,
                "dynamic": false,
                "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
                "title_case": false,
                "type": "int",
                "_input_type": "IntInput"
              },
              "model": {
                "tool_mode": false,
                "trace_as_metadata": true,
                "options": [
                  "claude-3-5-sonnet-latest",
                  "claude-3-5-haiku-latest",
                  "claude-3-opus-latest",
                  "claude-3-5-sonnet-20240620",
                  "claude-3-5-sonnet-20241022",
                  "claude-3-5-haiku-20241022",
                  "claude-3-sonnet-20240229",
                  "claude-3-haiku-20240307"
                ],
                "combobox": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "model",
                "value": "claude-3-5-sonnet-latest",
                "display_name": "Model Name",
                "advanced": false,
                "dynamic": false,
                "info": "https://python.langchain.com/docs/integrations/chat/anthropic",
                "title_case": false,
                "type": "str",
                "_input_type": "DropdownInput",
                "load_from_db": false
              },
              "prefill": {
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "prefill",
                "value": "",
                "display_name": "Prefill",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Prefill text to guide the model's response.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "stream": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "stream",
                "value": false,
                "display_name": "Stream",
                "advanced": false,
                "dynamic": false,
                "info": "Stream the response from the model. Streaming works only in Chat.",
                "title_case": false,
                "type": "bool",
                "_input_type": "BoolInput"
              },
              "system_message": {
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "system_message",
                "value": "",
                "display_name": "System Message",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "System message to pass to the model.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "temperature": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "temperature",
                "value": "0.7",
                "display_name": "Temperature",
                "advanced": false,
                "dynamic": false,
                "info": "",
                "title_case": false,
                "type": "float",
                "_input_type": "FloatInput",
                "load_from_db": false
              }
            },
            "description": "Generate text using Anthropic Chat&Completion LLMs with prefill support.",
            "icon": "Anthropic",
            "base_classes": [
              "LanguageModel",
              "Message"
            ],
            "display_name": "Anthropic",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "text_output",
                "display_name": "Text",
                "method": "text_response",
                "value": "__UNDEFINED__",
                "cache": true,
                "required_inputs": []
              },
              {
                "types": [
                  "LanguageModel"
                ],
                "selected": "LanguageModel",
                "name": "model_output",
                "display_name": "Language Model",
                "method": "build_model",
                "value": "__UNDEFINED__",
                "cache": true,
                "required_inputs": []
              }
            ],
            "field_order": [
              "input_value",
              "system_message",
              "stream",
              "max_tokens",
              "model",
              "anthropic_api_key",
              "temperature",
              "anthropic_api_url",
              "prefill",
              "output_parser"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false
          },
          "id": "AnthropicModel-FvFsG"
        },
        "selected": false,
        "width": 320,
        "height": 694,
        "dragging": false
      },
      {
        "id": "TextOutput-xfM5I",
        "type": "genericNode",
        "position": {
          "x": 3325.110609313505,
          "y": 336.2144347166377
        },
        "data": {
          "type": "TextOutput",
          "node": {
            "template": {
              "_type": "Component",
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextOutputComponent(TextComponent):\n    display_name = \"Text Output\"\n    description = \"Display a text output in the Playground.\"\n    icon = \"type\"\n    name = \"TextOutput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as output.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Text\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def text_response(self) -> Message:\n        message = Message(\n            text=self.input_value,\n        )\n        self.status = self.input_value\n        return message\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "input_value": {
                "trace_as_input": true,
                "multiline": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "input_value",
                "value": "",
                "display_name": "Text",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Text to be passed as output.",
                "title_case": false,
                "type": "str",
                "_input_type": "MultilineInput"
              }
            },
            "description": "Display a text output in the Playground.",
            "icon": "type",
            "base_classes": [
              "Message"
            ],
            "display_name": "RAG Results",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "text",
                "display_name": "Text",
                "method": "text_response",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "input_value"
            ],
            "beta": false,
            "edited": false,
            "lf_version": "1.1.1"
          },
          "id": "TextOutput-xfM5I"
        },
        "selected": false,
        "width": 320,
        "height": 234
      },
      {
        "id": "ParseJSONData-eeEA0",
        "type": "genericNode",
        "position": {
          "x": 2395.4762863362416,
          "y": 751.6951920322814
        },
        "data": {
          "type": "ParseJSONData",
          "node": {
            "template": {
              "_type": "Component",
              "input_value": {
                "trace_as_metadata": true,
                "list": false,
                "required": true,
                "placeholder": "",
                "show": true,
                "name": "input_value",
                "value": "",
                "display_name": "Input",
                "advanced": false,
                "input_types": [
                  "Message",
                  "Data"
                ],
                "dynamic": false,
                "info": "Data object to filter.",
                "title_case": false,
                "type": "other",
                "_input_type": "HandleInput"
              },
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "import json\nfrom json import JSONDecodeError\nfrom datetime import datetime, date\n\nimport jq\nfrom json_repair import repair_json\n\nfrom langflow.custom import Component\nfrom langflow.inputs import HandleInput, MessageTextInput\nfrom langflow.io import Output\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\n\n\nclass ParseJSONDataComponent(Component):\n    display_name = \"Parse JSON\"\n    description = \"Convert and extract JSON fields.\"\n    icon = \"braces\"\n    name = \"ParseJSONData\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n            info=\"Data object to filter.\",\n            required=True,\n            input_types=[\"Message\", \"Data\"],\n        ),\n        MessageTextInput(\n            name=\"query\",\n            display_name=\"JQ Query\",\n            info=\"JQ Query to filter the data. The input is always a JSON list.\",\n            required=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Filtered Data\", name=\"filtered_data\", method=\"filter_data\"),\n    ]\n\n    def _parse_data(self, input_value) -> str:\n        if isinstance(input_value, Message) and isinstance(input_value.text, str):\n            return input_value.text\n        if isinstance(input_value, Data):\n            return json.dumps(input_value.data, default=self._serialize_datetime)  # Use custom serializer\n        return str(input_value)\n\n    # Custom serializer function\n    @staticmethod\n    def _serialize_datetime(obj):\n        if isinstance(obj, (datetime, date)):\n            return obj.isoformat()  # Convert datetime/date to ISO format string\n        raise TypeError(f\"Object of type {obj.__class__.__name__} is not JSON serializable\")\n\n    def filter_data(self) -> list[Data]:\n        to_filter = self.input_value\n        if not to_filter:\n            return []\n        if isinstance(to_filter, list):\n            to_filter = [self._parse_data(f) for f in to_filter]\n        else:\n            to_filter = [self._parse_data(to_filter)]\n\n        to_filter = [repair_json(f) for f in to_filter]\n        to_filter_as_dict = []\n        for f in to_filter:\n            try:\n                to_filter_as_dict.append(json.loads(f))\n            except JSONDecodeError:\n                try:\n                    to_filter_as_dict.append(json.loads(repair_json(f)))\n                except JSONDecodeError as e:\n                    raise ValueError(f\"Invalid JSON: {e}\")\n\n        full_filter_str = json.dumps(to_filter_as_dict)\n\n        print(\"to_filter: \", to_filter)\n\n        results = jq.compile(self.query).input_text(full_filter_str).all()\n        print(\"results: \", results)\n        docs = [Data(data=value) if isinstance(value, dict) else Data(text=str(value)) for value in results]\n        return docs\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "query": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": true,
                "placeholder": "",
                "show": true,
                "name": "query",
                "value": ".[] | {   text,   likes_count: (.likes // \"0\"),   comments_count: (.comments // \"0\"),   shares_count: (.shares // \"0\"),   create_time: (.create_time // \"Not specified\"),   user_age_group_years: (.age // \"Not specified\"),   user_gender: (.gender // \"Not Specified\"),   user_country: (.country // \"Unknown\"),   user_follower_count: (.follower_count // \"Not specified\"),   platform: .platform }",
                "display_name": "JQ Query",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "JQ Query to filter the data. The input is always a JSON list.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              }
            },
            "description": "Convert and extract JSON fields.",
            "icon": "braces",
            "base_classes": [
              "Data"
            ],
            "display_name": "Parse JSON",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": true,
            "outputs": [
              {
                "types": [
                  "Data"
                ],
                "selected": "Data",
                "name": "filtered_data",
                "display_name": "Filtered Data",
                "method": "filter_data",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "input_value",
              "query"
            ],
            "beta": false,
            "edited": true,
            "lf_version": "1.1.1"
          },
          "id": "ParseJSONData-eeEA0"
        },
        "selected": false,
        "width": 320,
        "height": 282
      },
      {
        "id": "TextInput-n0QkP",
        "type": "genericNode",
        "position": {
          "x": 444.40049774184195,
          "y": 1005.9937607583115
        },
        "data": {
          "type": "TextInput",
          "node": {
            "template": {
              "_type": "Component",
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextInputComponent(TextComponent):\n    display_name = \"Text Input\"\n    description = \"Get text inputs from the Playground.\"\n    icon = \"type\"\n    name = \"TextInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as input.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Text\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def text_response(self) -> Message:\n        return Message(\n            text=self.input_value,\n        )\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "input_value": {
                "tool_mode": false,
                "trace_as_input": true,
                "multiline": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "input_value",
                "value": "0",
                "display_name": "Text",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Text to be passed as input.",
                "title_case": false,
                "type": "str",
                "_input_type": "MultilineInput"
              }
            },
            "description": "Get text inputs from the Playground.",
            "icon": "type",
            "base_classes": [
              "Message"
            ],
            "display_name": "Tribe",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": true,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "text",
                "display_name": "Text",
                "method": "text_response",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "input_value"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false,
            "lf_version": "1.1.1"
          },
          "id": "TextInput-n0QkP"
        },
        "selected": false,
        "width": 320,
        "height": 234
      },
      {
        "id": "MetaDataFilterConstructor-vAJyP",
        "type": "genericNode",
        "position": {
          "x": 941.6643041640377,
          "y": 988.1072763267196
        },
        "data": {
          "type": "MetaDataFilterConstructor",
          "node": {
            "template": {
              "_type": "Component",
              "age": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "age",
                "value": "",
                "display_name": "Age Group (<=18, 19_29, 30_39, 40+)",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Age group demographic",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "import json\nfrom datetime import datetime\n\nfrom langflow.custom import Component\nfrom langflow.inputs import MessageTextInput\nfrom langflow.template import Output\nfrom langflow.schema.message import Message\n\n\nclass MetaDataFilterConstructor(Component):\n    display_name = \"Search Meta Data Filter Constructor\"\n    description = \"A custom component to allow user to input pre-filter criteria\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"tribe\",\n            display_name=\"Tribe Name\",\n            info=\"Enter the ID of a specific tribe\"\n        ),\n        MessageTextInput(\n            name=\"likes_minimum\",\n            display_name=\"Minimum likes count\",\n            info=\"Minimum number of likes to qualify\"\n        ),\n        MessageTextInput(\n            name=\"platform\",\n            display_name=\"Platform (TikTok, Facebook, Twitter or YouTube)\",\n            info=\"TikTok, Facebook, Twitter or YouTube\"\n        ),\n        MessageTextInput(\n            name=\"gender\",\n            display_name=\"Gender\",\n            info=\"Male or Female\"\n        ),\n        MessageTextInput(\n            name=\"age\",\n            display_name=\"Age Group (<=18, 19_29, 30_39, 40+)\",\n            info=\"Age group demographic\"\n        ),\n        MessageTextInput(\n            name=\"country\",\n            display_name=\"Country (UK, US, DE, IN, CN, etc.)\",\n            info=\"UK, US, DE, IN, CN, etc.\"\n        ),\n        MessageTextInput(\n            name=\"datetime_from\",\n            display_name=\"From\",\n            info=\"Find posts/comments posted on or after this date (YYYY-MM-DD)\"\n        ),\n        MessageTextInput(\n            name=\"datetime_to\",\n            display_name=\"To\",\n            info=\"Find posts/comments posted on or before this date (YYYY-MM-DD)\"\n        ),\n        MessageTextInput(\n            name=\"followers\",\n            display_name=\"Min. Follower Count\",\n            info=\"At least this many followers\"\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Result\", name=\"result\", method=\"process_inputs\"),\n    ]\n\n    def process_inputs(self) -> Message:\n        \"\"\"\n        Create a Vector DB metadata filter.\n\n        Returns:\n            Message: A message object containing the processed information.\n        \"\"\"\n        try:\n            search_filter = []\n\n            if self.likes_minimum is not None and self.likes_minimum != \"\":\n                search_filter.append({\n                    \"field\": \"likes\",\n                    \"operator\": \"gte\",\n                    \"value\": int(self.likes_minimum)\n                })\n\n            if self.followers is not None and self.followers != \"\":\n                search_filter.append({\n                    \"field\": \"follower_count\",\n                    \"operator\": \"gte\",\n                    \"value\": int(self.followers)\n                })\n\n            if self.tribe is not None and self.tribe != \"\":\n                search_filter.append({\n                    \"field\": \"tribe\",\n                    \"operator\": \"eq\",\n                    \"value\": int(self.tribe)\n                })\n\n            for field in ['platform', 'gender', 'type', 'country', 'age']:\n                value = getattr(self, field, None)\n                if value is not None and value != \"\":\n                    search_filter.append({\n                        \"field\": field,\n                        \"operator\": \"eq\",\n                        \"value\": str(value)\n                    })\n\n\n            if self.datetime_from or self.datetime_to:\n                try:\n                    if self.datetime_from:\n                        datetime_from_obj = datetime.strptime(self.datetime_from, \"%Y-%m-%d\")\n                        search_filter.append({\n                            \"field\": \"create_time\",\n                            \"operator\": \"gte\",\n                            \"value\": datetime_from_obj.strftime(\"%Y-%m\")\n                        })\n                    if self.datetime_to:\n                        datetime_to_obj = datetime.strptime(self.datetime_to, \"%Y-%m-%d\")\n                        search_filter.append({\n                            \"field\": \"create_time\",\n                            \"operator\": \"lte\",\n                            \"value\": datetime_to_obj.strftime(\"%Y-%m\")\n                        })\n                except ValueError:\n                    return Message(text=\"Invalid datetime format. Please use YYYY-MM-DD.\")\n\n            if not search_filter:\n                return Message(text=\"No filter criteria provided.\")\n\n            return Message(text=json.dumps(search_filter, indent=4))\n        except AttributeError as e:\n            return Message(text=f\"Error processing inputs: {str(e)}\")\n\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "country": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "country",
                "value": "",
                "display_name": "Country (UK, US, DE, IN, CN, etc.)",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "UK, US, DE, IN, CN, etc.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "datetime_from": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "datetime_from",
                "value": "",
                "display_name": "From",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Find posts/comments posted on or after this date (YYYY-MM-DD)",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "datetime_to": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "datetime_to",
                "value": "",
                "display_name": "To",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Find posts/comments posted on or before this date (YYYY-MM-DD)",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "followers": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "followers",
                "value": "",
                "display_name": "Min. Follower Count",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "At least this many followers",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "gender": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "gender",
                "value": "",
                "display_name": "Gender",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Male or Female",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "likes_minimum": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "likes_minimum",
                "value": "",
                "display_name": "Minimum likes count",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Minimum number of likes to qualify",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "platform": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "platform",
                "value": "",
                "display_name": "Platform (TikTok, Facebook, Twitter or YouTube)",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "TikTok, Facebook, Twitter or YouTube",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "tribe": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "tribe",
                "value": "",
                "display_name": "Tribe Name",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Enter the ID of a specific tribe",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              }
            },
            "description": "A custom component to allow user to input pre-filter criteria",
            "base_classes": [
              "Message"
            ],
            "display_name": "Search Meta Data Pre-filter Constructor",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": true,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "result",
                "display_name": "Result",
                "method": "process_inputs",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "tribe",
              "likes_minimum",
              "platform",
              "gender",
              "age",
              "country",
              "datetime_from",
              "datetime_to",
              "followers"
            ],
            "beta": false,
            "edited": true,
            "lf_version": "1.1.1"
          },
          "id": "MetaDataFilterConstructor-vAJyP"
        },
        "selected": false,
        "width": 320,
        "height": 946
      },
      {
        "id": "TextInput-P1BmY",
        "type": "genericNode",
        "position": {
          "x": 435.8508601263263,
          "y": 1320.033855861002
        },
        "data": {
          "type": "TextInput",
          "node": {
            "template": {
              "_type": "Component",
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextInputComponent(TextComponent):\n    display_name = \"Text Input\"\n    description = \"Get text inputs from the Playground.\"\n    icon = \"type\"\n    name = \"TextInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as input.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Text\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def text_response(self) -> Message:\n        return Message(\n            text=self.input_value,\n        )\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "input_value": {
                "tool_mode": false,
                "trace_as_input": true,
                "multiline": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "input_value",
                "value": "100",
                "display_name": "Text",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Text to be passed as input.",
                "title_case": false,
                "type": "str",
                "_input_type": "MultilineInput"
              }
            },
            "description": "Get text inputs from the Playground.",
            "icon": "type",
            "base_classes": [
              "Message"
            ],
            "display_name": "Minimum likes",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": true,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "text",
                "display_name": "Text",
                "method": "text_response",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "input_value"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false,
            "lf_version": "1.1.1"
          },
          "id": "TextInput-P1BmY"
        },
        "selected": false,
        "width": 320,
        "height": 234,
        "positionAbsolute": {
          "x": 435.8508601263263,
          "y": 1320.033855861002
        },
        "dragging": false
      },
      {
        "id": "TextInput-4wKnt",
        "type": "genericNode",
        "position": {
          "x": 30.33446800874094,
          "y": 1641.9437943473215
        },
        "data": {
          "type": "TextInput",
          "node": {
            "template": {
              "_type": "Component",
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextInputComponent(TextComponent):\n    display_name = \"Text Input\"\n    description = \"Get text inputs from the Playground.\"\n    icon = \"type\"\n    name = \"TextInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as input.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Text\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def text_response(self) -> Message:\n        return Message(\n            text=self.input_value,\n        )\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "input_value": {
                "tool_mode": false,
                "trace_as_input": true,
                "multiline": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "input_value",
                "value": "",
                "display_name": "Text",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Text to be passed as input.",
                "title_case": false,
                "type": "str",
                "_input_type": "MultilineInput"
              }
            },
            "description": "Get text inputs from the Playground.",
            "icon": "type",
            "base_classes": [
              "Message"
            ],
            "display_name": "Age group",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": true,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "text",
                "display_name": "Text",
                "method": "text_response",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "input_value"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false,
            "lf_version": "1.1.1"
          },
          "id": "TextInput-4wKnt"
        },
        "selected": false,
        "width": 320,
        "height": 234
      },
      {
        "id": "TextInput-wg8O0",
        "type": "genericNode",
        "position": {
          "x": 26.336456485062172,
          "y": 1958.5130346714946
        },
        "data": {
          "type": "TextInput",
          "node": {
            "template": {
              "_type": "Component",
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextInputComponent(TextComponent):\n    display_name = \"Text Input\"\n    description = \"Get text inputs from the Playground.\"\n    icon = \"type\"\n    name = \"TextInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as input.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Text\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def text_response(self) -> Message:\n        return Message(\n            text=self.input_value,\n        )\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "input_value": {
                "tool_mode": false,
                "trace_as_input": true,
                "multiline": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "input_value",
                "value": "",
                "display_name": "Text",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Text to be passed as input.",
                "title_case": false,
                "type": "str",
                "_input_type": "MultilineInput"
              }
            },
            "description": "Get text inputs from the Playground.",
            "icon": "type",
            "base_classes": [
              "Message"
            ],
            "display_name": "Country",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": true,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "text",
                "display_name": "Text",
                "method": "text_response",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "input_value"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false,
            "lf_version": "1.1.1"
          },
          "id": "TextInput-wg8O0"
        },
        "selected": false,
        "width": 320,
        "height": 234
      },
      {
        "id": "TextInput-aYfSJ",
        "type": "genericNode",
        "position": {
          "x": 445.351676804637,
          "y": 1955.4309957000953
        },
        "data": {
          "type": "TextInput",
          "node": {
            "template": {
              "_type": "Component",
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextInputComponent(TextComponent):\n    display_name = \"Text Input\"\n    description = \"Get text inputs from the Playground.\"\n    icon = \"type\"\n    name = \"TextInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as input.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Text\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def text_response(self) -> Message:\n        return Message(\n            text=self.input_value,\n        )\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "input_value": {
                "tool_mode": false,
                "trace_as_input": true,
                "multiline": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "input_value",
                "value": "",
                "display_name": "Text",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Text to be passed as input.",
                "title_case": false,
                "type": "str",
                "_input_type": "MultilineInput"
              }
            },
            "description": "Get text inputs from the Playground.",
            "icon": "type",
            "base_classes": [
              "Message"
            ],
            "display_name": "Platform",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": true,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "text",
                "display_name": "Text",
                "method": "text_response",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "input_value"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false,
            "lf_version": "1.1.1"
          },
          "id": "TextInput-aYfSJ"
        },
        "selected": false,
        "width": 320,
        "height": 234
      },
      {
        "id": "TextInput-WCBMY",
        "type": "genericNode",
        "position": {
          "x": 24.797599840879684,
          "y": 1330.194121254331
        },
        "data": {
          "type": "TextInput",
          "node": {
            "template": {
              "_type": "Component",
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextInputComponent(TextComponent):\n    display_name = \"Text Input\"\n    description = \"Get text inputs from the Playground.\"\n    icon = \"type\"\n    name = \"TextInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as input.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Text\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def text_response(self) -> Message:\n        return Message(\n            text=self.input_value,\n        )\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "input_value": {
                "tool_mode": false,
                "trace_as_input": true,
                "multiline": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "input_value",
                "value": "",
                "display_name": "Text",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Text to be passed as input.",
                "title_case": false,
                "type": "str",
                "_input_type": "MultilineInput"
              }
            },
            "description": "Get text inputs from the Playground.",
            "icon": "type",
            "base_classes": [
              "Message"
            ],
            "display_name": "Gender",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": true,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "text",
                "display_name": "Text",
                "method": "text_response",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "input_value"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false,
            "lf_version": "1.1.1"
          },
          "id": "TextInput-WCBMY"
        },
        "selected": false,
        "width": 320,
        "height": 234,
        "dragging": false
      },
      {
        "id": "TextInput-Uk4ri",
        "type": "genericNode",
        "position": {
          "x": 453.82929166584086,
          "y": 1630.3544438127426
        },
        "data": {
          "type": "TextInput",
          "node": {
            "template": {
              "_type": "Component",
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextInputComponent(TextComponent):\n    display_name = \"Text Input\"\n    description = \"Get text inputs from the Playground.\"\n    icon = \"type\"\n    name = \"TextInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as input.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Text\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def text_response(self) -> Message:\n        return Message(\n            text=self.input_value,\n        )\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "input_value": {
                "tool_mode": false,
                "trace_as_input": true,
                "multiline": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "input_value",
                "value": "",
                "display_name": "Text",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Text to be passed as input.",
                "title_case": false,
                "type": "str",
                "_input_type": "MultilineInput"
              }
            },
            "description": "Get text inputs from the Playground.",
            "icon": "type",
            "base_classes": [
              "Message"
            ],
            "display_name": "From (YYYY-MM)",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": true,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "text",
                "display_name": "Text",
                "method": "text_response",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "input_value"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false,
            "lf_version": "1.1.1"
          },
          "id": "TextInput-Uk4ri"
        },
        "selected": false,
        "width": 320,
        "height": 234
      },
      {
        "id": "Memory-MeAfJ",
        "type": "genericNode",
        "position": {
          "x": 2572.4718352496175,
          "y": 1192.427983177174
        },
        "data": {
          "type": "Memory",
          "node": {
            "template": {
              "_type": "Component",
              "memory": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "memory",
                "value": "",
                "display_name": "External Memory",
                "advanced": false,
                "input_types": [
                  "BaseChatMessageHistory"
                ],
                "dynamic": false,
                "info": "Retrieve messages from an external memory. If empty, it will use the Langflow tables.",
                "title_case": false,
                "type": "other",
                "_input_type": "HandleInput"
              },
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langchain.memory import ConversationBufferMemory\n\nfrom langflow.custom import Component\nfrom langflow.field_typing import BaseChatMemory\nfrom langflow.helpers.data import data_to_text\nfrom langflow.inputs import HandleInput\nfrom langflow.io import DropdownInput, IntInput, MessageTextInput, MultilineInput, Output\nfrom langflow.memory import LCBuiltinChatMemory, get_messages\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_USER\n\n\nclass MemoryComponent(Component):\n    display_name = \"Message History\"\n    description = \"Retrieves stored chat messages from Langflow tables or an external memory.\"\n    icon = \"message-square-more\"\n    name = \"Memory\"\n\n    inputs = [\n        HandleInput(\n            name=\"memory\",\n            display_name=\"External Memory\",\n            input_types=[\"BaseChatMessageHistory\"],\n            info=\"Retrieve messages from an external memory. If empty, it will use the Langflow tables.\",\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER, \"Machine and User\"],\n            value=\"Machine and User\",\n            info=\"Filter by sender type.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Filter by sender name.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"n_messages\",\n            display_name=\"Number of Messages\",\n            value=100,\n            info=\"Number of messages to retrieve.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"order\",\n            display_name=\"Order\",\n            options=[\"Ascending\", \"Descending\"],\n            value=\"Ascending\",\n            info=\"Order of the messages.\",\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. \"\n            \"It can contain the keys {text}, {sender} or any other key in the message data.\",\n            value=\"{sender_name}: {text}\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"messages\", method=\"retrieve_messages\"),\n        Output(display_name=\"Text\", name=\"messages_text\", method=\"retrieve_messages_as_text\"),\n    ]\n\n    def retrieve_messages(self) -> Data:\n        sender = self.sender\n        sender_name = self.sender_name\n        session_id = self.session_id\n        n_messages = self.n_messages\n        order = \"DESC\" if self.order == \"Descending\" else \"ASC\"\n\n        if sender == \"Machine and User\":\n            sender = None\n\n        if self.memory:\n            # override session_id\n            self.memory.session_id = session_id\n\n            stored = self.memory.messages\n            # langchain memories are supposed to return messages in ascending order\n            if order == \"DESC\":\n                stored = stored[::-1]\n            if n_messages:\n                stored = stored[:n_messages]\n            stored = [Message.from_lc_message(m) for m in stored]\n            if sender:\n                expected_type = MESSAGE_SENDER_AI if sender == MESSAGE_SENDER_AI else MESSAGE_SENDER_USER\n                stored = [m for m in stored if m.type == expected_type]\n        else:\n            stored = get_messages(\n                sender=sender,\n                sender_name=sender_name,\n                session_id=session_id,\n                limit=n_messages,\n                order=order,\n            )\n        self.status = stored\n        return stored\n\n    def retrieve_messages_as_text(self) -> Message:\n        stored_text = data_to_text(self.template, self.retrieve_messages())\n        self.status = stored_text\n        return Message(text=stored_text)\n\n    def build_lc_memory(self) -> BaseChatMemory:\n        chat_memory = self.memory or LCBuiltinChatMemory(flow_id=self.flow_id, session_id=self.session_id)\n        return ConversationBufferMemory(chat_memory=chat_memory)\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "n_messages": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "n_messages",
                "value": 20,
                "display_name": "Number of Messages",
                "advanced": true,
                "dynamic": false,
                "info": "Number of messages to retrieve.",
                "title_case": false,
                "type": "int",
                "_input_type": "IntInput",
                "load_from_db": false
              },
              "order": {
                "tool_mode": false,
                "trace_as_metadata": true,
                "options": [
                  "Ascending",
                  "Descending"
                ],
                "combobox": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "order",
                "value": "Ascending",
                "display_name": "Order",
                "advanced": true,
                "dynamic": false,
                "info": "Order of the messages.",
                "title_case": false,
                "type": "str",
                "_input_type": "DropdownInput"
              },
              "sender": {
                "tool_mode": false,
                "trace_as_metadata": true,
                "options": [
                  "Machine",
                  "User",
                  "Machine and User"
                ],
                "combobox": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "sender",
                "value": "Machine and User",
                "display_name": "Sender Type",
                "advanced": true,
                "dynamic": false,
                "info": "Filter by sender type.",
                "title_case": false,
                "type": "str",
                "_input_type": "DropdownInput"
              },
              "sender_name": {
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "sender_name",
                "value": "",
                "display_name": "Sender Name",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Filter by sender name.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "session_id": {
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "session_id",
                "value": "",
                "display_name": "Session ID",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "template": {
                "tool_mode": false,
                "trace_as_input": true,
                "multiline": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "template",
                "value": "{sender_name}: {text}",
                "display_name": "Template",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The template to use for formatting the data. It can contain the keys {text}, {sender} or any other key in the message data.",
                "title_case": false,
                "type": "str",
                "_input_type": "MultilineInput"
              }
            },
            "description": "Retrieves stored chat messages from Langflow tables or an external memory.",
            "icon": "message-square-more",
            "base_classes": [
              "Data",
              "Message"
            ],
            "display_name": "Chat Memory",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": true,
            "outputs": [
              {
                "types": [
                  "Data"
                ],
                "selected": "Data",
                "name": "messages",
                "display_name": "Data",
                "method": "retrieve_messages",
                "value": "__UNDEFINED__",
                "cache": true
              },
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "messages_text",
                "display_name": "Text",
                "method": "retrieve_messages_as_text",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "memory",
              "sender",
              "sender_name",
              "n_messages",
              "session_id",
              "order",
              "template"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false,
            "lf_version": "1.1.1"
          },
          "id": "Memory-MeAfJ"
        },
        "selected": false,
        "width": 320,
        "height": 264,
        "positionAbsolute": {
          "x": 2572.4718352496175,
          "y": 1192.427983177174
        },
        "dragging": false
      },
      {
        "id": "Prompt-oU1Ym",
        "type": "genericNode",
        "position": {
          "x": 3283.166228639823,
          "y": 727.8634921875658
        },
        "data": {
          "type": "Prompt",
          "node": {
            "template": {
              "_type": "Component",
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"Prompt\"\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt Message\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(\n        self,\n    ) -> Message:\n        prompt = await Message.from_template_and_variables(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        if custom_fields[\"rag_query\"].text.strip().lower() == \"disabled\":\n            custom_fields[\"rag_query\"].text = \"RAG was not used in this query\"\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    def post_code_processing(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"\n        This function is called after the code validation is done.\n        \"\"\"\n        frontend_node = super().post_code_processing(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "template": {
                "trace_as_input": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "template",
                "value": "Chat history:\n\n{history}\n\n------------------------------\n\nBelow are a number of real, relevant results from 4 social media platforms (TikTok, Facebook, YouTube, and Twitter).\n\nThey are in a variety of languages so when you come across them please translate them into English and pass along your findings.\n\nHere are the snippets:\n\n{context}\n\n------------------------------\n\nUsing the social media posts and comments provided above do your best to answer the below question. (And don't forget in your analysis to also include some direct verbatim quotes from the text snippets from the text snippets where appropriate!)!)\n\nQuestion: {question}\n\nAnswer:\n",
                "display_name": "Template",
                "advanced": false,
                "dynamic": false,
                "info": "",
                "title_case": false,
                "type": "prompt",
                "_input_type": "PromptInput",
                "load_from_db": false
              },
              "history": {
                "field_type": "str",
                "required": false,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "",
                "fileTypes": [],
                "file_path": "",
                "name": "history",
                "display_name": "history",
                "advanced": false,
                "input_types": [
                  "Message",
                  "Text"
                ],
                "dynamic": false,
                "info": "",
                "load_from_db": false,
                "title_case": false,
                "type": "str"
              },
              "context": {
                "field_type": "str",
                "required": false,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "",
                "fileTypes": [],
                "file_path": "",
                "name": "context",
                "display_name": "context",
                "advanced": false,
                "input_types": [
                  "Message",
                  "Text"
                ],
                "dynamic": false,
                "info": "",
                "load_from_db": false,
                "title_case": false,
                "type": "str"
              },
              "question": {
                "field_type": "str",
                "required": false,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "",
                "fileTypes": [],
                "file_path": "",
                "name": "question",
                "display_name": "question",
                "advanced": false,
                "input_types": [
                  "Message",
                  "Text"
                ],
                "dynamic": false,
                "info": "",
                "load_from_db": false,
                "title_case": false,
                "type": "str"
              }
            },
            "description": "Create a prompt template with dynamic variables.",
            "icon": "prompts",
            "is_input": null,
            "is_output": null,
            "is_composition": null,
            "base_classes": [
              "Message"
            ],
            "name": "",
            "display_name": "Prompt",
            "documentation": "",
            "custom_fields": {
              "template": [
                "history",
                "context",
                "question"
              ]
            },
            "output_types": [],
            "full_path": null,
            "pinned": false,
            "conditional_paths": [],
            "frozen": true,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "prompt",
                "hidden": null,
                "display_name": "Prompt Message",
                "method": "build_prompt",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "template"
            ],
            "beta": false,
            "error": null,
            "edited": true,
            "lf_version": "1.1.1"
          },
          "id": "Prompt-oU1Ym"
        },
        "selected": false,
        "width": 320,
        "height": 520,
        "dragging": false
      },
      {
        "id": "TextInput-JZobh",
        "type": "genericNode",
        "position": {
          "x": 338.10595483576617,
          "y": 349.39457238544253
        },
        "data": {
          "type": "TextInput",
          "node": {
            "template": {
              "_type": "Component",
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextInputComponent(TextComponent):\n    display_name = \"Text Input\"\n    description = \"Get text inputs from the Playground.\"\n    icon = \"type\"\n    name = \"TextInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as input.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Text\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def text_response(self) -> Message:\n        return Message(\n            text=self.input_value,\n        )\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "input_value": {
                "tool_mode": false,
                "trace_as_input": true,
                "multiline": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "input_value",
                "value": "climate change opinions and sentiment reactions to brands and conversations around global warming and sustainability",
                "display_name": "Text",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Text to be passed as input.",
                "title_case": false,
                "type": "str",
                "_input_type": "MultilineInput"
              }
            },
            "description": "Get text inputs from the Playground.",
            "icon": "type",
            "base_classes": [
              "Message"
            ],
            "display_name": "RAG Search Query",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": true,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "text",
                "display_name": "Text",
                "method": "text_response",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "input_value"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false,
            "lf_version": "1.1.1"
          },
          "id": "TextInput-JZobh"
        },
        "selected": false,
        "width": 320,
        "height": 234,
        "positionAbsolute": {
          "x": 338.10595483576617,
          "y": 349.39457238544253
        },
        "dragging": false
      },
      {
        "id": "TextInput-UhThw",
        "type": "genericNode",
        "position": {
          "x": 20,
          "y": 1014.9895032751836
        },
        "data": {
          "type": "TextInput",
          "node": {
            "template": {
              "_type": "Component",
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextInputComponent(TextComponent):\n    display_name = \"Text Input\"\n    description = \"Get text inputs from the Playground.\"\n    icon = \"type\"\n    name = \"TextInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as input.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Text\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def text_response(self) -> Message:\n        return Message(\n            text=self.input_value,\n        )\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "input_value": {
                "tool_mode": false,
                "trace_as_input": true,
                "multiline": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "input_value",
                "value": "250",
                "display_name": "Text",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Text to be passed as input.",
                "title_case": false,
                "type": "str",
                "_input_type": "MultilineInput"
              }
            },
            "description": "Get text inputs from the Playground.",
            "icon": "type",
            "base_classes": [
              "Message"
            ],
            "display_name": "Min. Follower Count",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": true,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "text",
                "display_name": "Text",
                "method": "text_response",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "input_value"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false,
            "lf_version": "1.1.1"
          },
          "id": "TextInput-UhThw"
        },
        "selected": false,
        "width": 320,
        "height": 234
      },
      {
        "id": "OpenAIModel-wA6hw",
        "type": "genericNode",
        "position": {
          "x": 3873.444435094526,
          "y": 1488.5470895563728
        },
        "data": {
          "type": "OpenAIModel",
          "node": {
            "template": {
              "_type": "Component",
              "output_parser": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "output_parser",
                "value": "",
                "display_name": "Output Parser",
                "advanced": true,
                "input_types": [
                  "OutputParser"
                ],
                "dynamic": false,
                "info": "The parser to use to parse the output of the model",
                "title_case": false,
                "type": "other",
                "_input_type": "HandleInput"
              },
              "api_key": {
                "load_from_db": true,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "api_key",
                "value": "OPENAI_API_KEY",
                "display_name": "OpenAI API Key",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The OpenAI API Key to use for the OpenAI model.",
                "title_case": false,
                "password": true,
                "type": "str",
                "_input_type": "SecretStrInput"
              },
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "import operator\nfrom functools import reduce\n\nfrom langchain_openai import ChatOpenAI\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.base.models.openai_constants import OPENAI_MODEL_NAMES\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import BoolInput, DictInput, DropdownInput, FloatInput, IntInput, SecretStrInput, StrInput\nfrom langflow.inputs.inputs import HandleInput\n\n\nclass OpenAIModelComponent(LCModelComponent):\n    display_name = \"OpenAI\"\n    description = \"Generates text using OpenAI LLMs.\"\n    icon = \"OpenAI\"\n    name = \"OpenAIModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n            range_spec=RangeSpec(min=0, max=128000),\n        ),\n        DictInput(\n            name=\"model_kwargs\",\n            display_name=\"Model Kwargs\",\n            advanced=True,\n            info=\"Additional keyword arguments to pass to the model.\",\n        ),\n        BoolInput(\n            name=\"json_mode\",\n            display_name=\"JSON Mode\",\n            advanced=True,\n            info=\"If True, it will output JSON regardless of passing a schema.\",\n        ),\n        DictInput(\n            name=\"output_schema\",\n            is_list=True,\n            display_name=\"Schema\",\n            advanced=True,\n            info=\"The schema for the Output of the model. \"\n            \"You must pass the word JSON in the prompt. \"\n            \"If left blank, JSON mode will be disabled. [DEPRECATED]\",\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            advanced=False,\n            options=OPENAI_MODEL_NAMES,\n            value=OPENAI_MODEL_NAMES[0],\n        ),\n        StrInput(\n            name=\"openai_api_base\",\n            display_name=\"OpenAI API Base\",\n            advanced=True,\n            info=\"The base URL of the OpenAI API. \"\n            \"Defaults to https://api.openai.com/v1. \"\n            \"You can change this to use other APIs like JinaChat, LocalAI and Prem.\",\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"OpenAI API Key\",\n            info=\"The OpenAI API Key to use for the OpenAI model.\",\n            advanced=False,\n            value=\"OPENAI_API_KEY\",\n        ),\n        FloatInput(name=\"temperature\", display_name=\"Temperature\", value=0.1),\n        IntInput(\n            name=\"seed\",\n            display_name=\"Seed\",\n            info=\"The seed controls the reproducibility of the job.\",\n            advanced=True,\n            value=1,\n        ),\n        HandleInput(\n            name=\"output_parser\",\n            display_name=\"Output Parser\",\n            info=\"The parser to use to parse the output of the model\",\n            advanced=True,\n            input_types=[\"OutputParser\"],\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        # self.output_schema is a list of dictionaries\n        # let's convert it to a dictionary\n        output_schema_dict: dict[str, str] = reduce(operator.ior, self.output_schema or {}, {})\n        openai_api_key = self.api_key\n        temperature = self.temperature\n        model_name: str = self.model_name\n        max_tokens = self.max_tokens\n        model_kwargs = self.model_kwargs or {}\n        openai_api_base = self.openai_api_base or \"https://api.openai.com/v1\"\n        json_mode = bool(output_schema_dict) or self.json_mode\n        seed = self.seed\n\n        api_key = SecretStr(openai_api_key).get_secret_value() if openai_api_key else None\n        output = ChatOpenAI(\n            max_tokens=max_tokens or None,\n            model_kwargs=model_kwargs,\n            model=model_name,\n            base_url=openai_api_base,\n            api_key=api_key,\n            temperature=temperature if temperature is not None else 0.1,\n            seed=seed,\n        )\n        if json_mode:\n            if output_schema_dict:\n                output = output.with_structured_output(schema=output_schema_dict, method=\"json_mode\")\n            else:\n                output = output.bind(response_format={\"type\": \"json_object\"})\n\n        return output\n\n    def _get_exception_message(self, e: Exception):\n        \"\"\"Get a message from an OpenAI exception.\n\n        Args:\n            e (Exception): The exception to get the message from.\n\n        Returns:\n            str: The message from the exception.\n        \"\"\"\n        try:\n            from openai import BadRequestError\n        except ImportError:\n            return None\n        if isinstance(e, BadRequestError):\n            message = e.body.get(\"message\")\n            if message:\n                return message\n        return None\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "input_value": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "input_value",
                "value": "",
                "display_name": "Input",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageInput"
              },
              "json_mode": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "json_mode",
                "value": false,
                "display_name": "JSON Mode",
                "advanced": true,
                "dynamic": false,
                "info": "If True, it will output JSON regardless of passing a schema.",
                "title_case": false,
                "type": "bool",
                "_input_type": "BoolInput"
              },
              "max_tokens": {
                "trace_as_metadata": true,
                "range_spec": {
                  "step_type": "float",
                  "min": 0,
                  "max": 128000,
                  "step": 0.1
                },
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "max_tokens",
                "value": "",
                "display_name": "Max Tokens",
                "advanced": true,
                "dynamic": false,
                "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
                "title_case": false,
                "type": "int",
                "_input_type": "IntInput"
              },
              "model_kwargs": {
                "trace_as_input": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "model_kwargs",
                "value": {},
                "display_name": "Model Kwargs",
                "advanced": true,
                "dynamic": false,
                "info": "Additional keyword arguments to pass to the model.",
                "title_case": false,
                "type": "dict",
                "_input_type": "DictInput"
              },
              "model_name": {
                "tool_mode": false,
                "trace_as_metadata": true,
                "options": [
                  "gpt-4o-mini",
                  "gpt-4o",
                  "gpt-4-turbo",
                  "gpt-4-turbo-preview",
                  "gpt-4",
                  "gpt-3.5-turbo",
                  "gpt-3.5-turbo-0125"
                ],
                "combobox": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "model_name",
                "value": "gpt-4o",
                "display_name": "Model Name",
                "advanced": false,
                "dynamic": false,
                "info": "",
                "title_case": false,
                "type": "str",
                "_input_type": "DropdownInput",
                "load_from_db": false
              },
              "openai_api_base": {
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "openai_api_base",
                "value": "",
                "display_name": "OpenAI API Base",
                "advanced": true,
                "dynamic": false,
                "info": "The base URL of the OpenAI API. Defaults to https://api.openai.com/v1. You can change this to use other APIs like JinaChat, LocalAI and Prem.",
                "title_case": false,
                "type": "str",
                "_input_type": "StrInput"
              },
              "output_schema": {
                "trace_as_input": true,
                "list": true,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "output_schema",
                "value": {},
                "display_name": "Schema",
                "advanced": true,
                "dynamic": false,
                "info": "The schema for the Output of the model. You must pass the word JSON in the prompt. If left blank, JSON mode will be disabled. [DEPRECATED]",
                "title_case": false,
                "type": "dict",
                "_input_type": "DictInput"
              },
              "seed": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "seed",
                "value": 1,
                "display_name": "Seed",
                "advanced": true,
                "dynamic": false,
                "info": "The seed controls the reproducibility of the job.",
                "title_case": false,
                "type": "int",
                "_input_type": "IntInput"
              },
              "stream": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "stream",
                "value": false,
                "display_name": "Stream",
                "advanced": false,
                "dynamic": false,
                "info": "Stream the response from the model. Streaming works only in Chat.",
                "title_case": false,
                "type": "bool",
                "_input_type": "BoolInput"
              },
              "system_message": {
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "system_message",
                "value": "",
                "display_name": "System Message",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "System message to pass to the model.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "temperature": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "temperature",
                "value": "0.7",
                "display_name": "Temperature",
                "advanced": false,
                "dynamic": false,
                "info": "",
                "title_case": false,
                "type": "float",
                "_input_type": "FloatInput",
                "load_from_db": false
              }
            },
            "description": "Generates text using OpenAI LLMs.",
            "icon": "OpenAI",
            "base_classes": [
              "LanguageModel",
              "Message"
            ],
            "display_name": "OpenAI",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "text_output",
                "display_name": "Text",
                "method": "text_response",
                "value": "__UNDEFINED__",
                "cache": true,
                "required_inputs": []
              },
              {
                "types": [
                  "LanguageModel"
                ],
                "selected": "LanguageModel",
                "name": "model_output",
                "display_name": "Language Model",
                "method": "build_model",
                "value": "__UNDEFINED__",
                "cache": true,
                "required_inputs": []
              }
            ],
            "field_order": [
              "input_value",
              "system_message",
              "stream",
              "max_tokens",
              "model_kwargs",
              "json_mode",
              "output_schema",
              "model_name",
              "openai_api_base",
              "api_key",
              "temperature",
              "seed",
              "output_parser"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false,
            "lf_version": "1.1.1"
          },
          "id": "OpenAIModel-wA6hw"
        },
        "selected": false,
        "width": 320,
        "height": 674,
        "dragging": false
      },
      {
        "id": "CombineText-88DLO",
        "type": "genericNode",
        "position": {
          "x": 4401.794707090048,
          "y": 1151.3264278414092
        },
        "data": {
          "type": "CombineText",
          "node": {
            "template": {
              "_type": "Component",
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema.message import Message\n\n\nclass CombineTextComponent(Component):\n    display_name = \"Combine Text\"\n    description = \"Concatenate two text sources into a single text chunk using a specified delimiter.\"\n    icon = \"merge\"\n    name = \"CombineText\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"text1\",\n            display_name=\"First Text\",\n            info=\"The first text input to concatenate.\",\n        ),\n        MessageTextInput(\n            name=\"text2\",\n            display_name=\"Second Text\",\n            info=\"The second text input to concatenate.\",\n        ),\n        MessageTextInput(\n            name=\"delimiter\",\n            display_name=\"Delimiter\",\n            info=\"A string used to separate the two text inputs. Defaults to a whitespace.\",\n            value=\" \",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Combined Text\", name=\"combined_text\", method=\"combine_texts\"),\n    ]\n\n    def combine_texts(self) -> Message:\n        combined = self.delimiter.join([self.text1, self.text2])\n        self.status = combined\n        return Message(text=combined)\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "delimiter": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "delimiter",
                "value": " \\n\\n-----Chat-GPT----- \\n\\n",
                "display_name": "Delimiter",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "A string used to separate the two text inputs. Defaults to a whitespace.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "text1": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "text1",
                "value": "",
                "display_name": "First Text",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The first text input to concatenate.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "text2": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "text2",
                "value": "",
                "display_name": "Second Text",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The second text input to concatenate.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              }
            },
            "description": "Concatenate two text sources into a single text chunk using a specified delimiter.",
            "icon": "merge",
            "base_classes": [
              "Message"
            ],
            "display_name": "Combine Text",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "combined_text",
                "display_name": "Combined Text",
                "method": "combine_texts",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "text1",
              "text2",
              "delimiter"
            ],
            "beta": false,
            "edited": false,
            "lf_version": "1.0.18"
          },
          "id": "CombineText-88DLO"
        },
        "selected": false,
        "width": 320,
        "height": 427
      },
      {
        "id": "Prompt-Z36Yo",
        "type": "genericNode",
        "position": {
          "x": 3278.4656473001032,
          "y": 1497.9616292019555
        },
        "data": {
          "type": "Prompt",
          "node": {
            "template": {
              "_type": "Component",
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"Prompt\"\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt Message\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(\n        self,\n    ) -> Message:\n        prompt = await Message.from_template_and_variables(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        if custom_fields[\"rag_query\"].text.strip().lower() == \"disabled\":\n            custom_fields[\"rag_query\"].text = \"RAG was not used in this query\"\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    def post_code_processing(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"\n        This function is called after the code validation is done.\n        \"\"\"\n        frontend_node = super().post_code_processing(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "template": {
                "trace_as_input": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "template",
                "value": "Chat history:\n\n{history}\n\n------------------------------\n\nBelow are a number of real, relevant results from 4 social media platforms (TikTok, Facebook, YouTube, and Twitter). These snippets are all posts and comments that relate to \"{rag_query}\".\n\nThey are in a variety of languages so when you come across them please translate them into English and pass along your findings.\n\nHere are the snippets:\n\n{context}\n\n------------------------------\n\nUsing the social media posts and comments provided above do your best to answer the below question. (And don't forget in your analysis to also include some direct verbatim quotes from the text snippets from the text snippets where appropriate!)!)\n\nQuestion: {question}\n\nAnswer:\n",
                "display_name": "Template",
                "advanced": false,
                "dynamic": false,
                "info": "",
                "title_case": false,
                "type": "prompt",
                "_input_type": "PromptInput",
                "load_from_db": false
              },
              "history": {
                "field_type": "str",
                "required": false,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "",
                "fileTypes": [],
                "file_path": "",
                "name": "history",
                "display_name": "history",
                "advanced": false,
                "input_types": [
                  "Message",
                  "Text"
                ],
                "dynamic": false,
                "info": "",
                "load_from_db": false,
                "title_case": false,
                "type": "str"
              },
              "rag_query": {
                "field_type": "str",
                "required": false,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "",
                "fileTypes": [],
                "file_path": "",
                "name": "rag_query",
                "display_name": "rag_query",
                "advanced": false,
                "input_types": [
                  "Message",
                  "Text"
                ],
                "dynamic": false,
                "info": "",
                "load_from_db": false,
                "title_case": false,
                "type": "str"
              },
              "context": {
                "field_type": "str",
                "required": false,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "",
                "fileTypes": [],
                "file_path": "",
                "name": "context",
                "display_name": "context",
                "advanced": false,
                "input_types": [
                  "Message",
                  "Text"
                ],
                "dynamic": false,
                "info": "",
                "load_from_db": false,
                "title_case": false,
                "type": "str"
              },
              "question": {
                "field_type": "str",
                "required": false,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "",
                "fileTypes": [],
                "file_path": "",
                "name": "question",
                "display_name": "question",
                "advanced": false,
                "input_types": [
                  "Message",
                  "Text"
                ],
                "dynamic": false,
                "info": "",
                "load_from_db": false,
                "title_case": false,
                "type": "str"
              }
            },
            "description": "Create a prompt template with dynamic variables.",
            "icon": "prompts",
            "is_input": null,
            "is_output": null,
            "is_composition": null,
            "base_classes": [
              "Message"
            ],
            "name": "",
            "display_name": "Prompt",
            "documentation": "",
            "custom_fields": {
              "template": [
                "history",
                "rag_query",
                "context",
                "question"
              ]
            },
            "output_types": [],
            "full_path": null,
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "prompt",
                "hidden": null,
                "display_name": "Prompt Message",
                "method": "build_prompt",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "template"
            ],
            "beta": false,
            "error": null,
            "edited": true,
            "lf_version": "1.0.18"
          },
          "id": "Prompt-Z36Yo"
        },
        "selected": false,
        "width": 320,
        "height": 606
      },
      {
        "id": "AstraVectorize-TQ0Iz",
        "type": "genericNode",
        "position": {
          "x": 1327.12628065442,
          "y": 594.6723848582672
        },
        "data": {
          "node": {
            "template": {
              "_type": "Component",
              "api_key_name": {
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "api_key_name",
                "value": "OPENAI_API_KEY",
                "display_name": "API Key name",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The name of the embeddings provider API key stored on Astra. If set, it will override the 'ProviderKey' in the authentication parameters.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "authentication": {
                "trace_as_input": true,
                "list": true,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "authentication",
                "value": {},
                "display_name": "Authentication Parameters",
                "advanced": true,
                "dynamic": false,
                "info": "",
                "title_case": false,
                "type": "dict",
                "_input_type": "DictInput"
              },
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import DictInput, DropdownInput, MessageTextInput, SecretStrInput\nfrom langflow.template.field.base import Output\n\n\nclass AstraVectorizeComponent(Component):\n    display_name: str = \"Astra Vectorize [DEPRECATED]\"\n    description: str = (\n        \"Configuration options for Astra Vectorize server-side embeddings. \"\n        \"This component is deprecated. Please use the Astra DB Component directly.\"\n    )\n    documentation: str = \"https://docs.datastax.com/en/astra-db-serverless/databases/embedding-generation.html\"\n    icon = \"AstraDB\"\n    name = \"AstraVectorize\"\n\n    VECTORIZE_PROVIDERS_MAPPING = {\n        \"Azure OpenAI\": [\"azureOpenAI\", [\"text-embedding-3-small\", \"text-embedding-3-large\", \"text-embedding-ada-002\"]],\n        \"Hugging Face - Dedicated\": [\"huggingfaceDedicated\", [\"endpoint-defined-model\"]],\n        \"Hugging Face - Serverless\": [\n            \"huggingface\",\n            [\n                \"sentence-transformers/all-MiniLM-L6-v2\",\n                \"intfloat/multilingual-e5-large\",\n                \"intfloat/multilingual-e5-large-instruct\",\n                \"BAAI/bge-small-en-v1.5\",\n                \"BAAI/bge-base-en-v1.5\",\n                \"BAAI/bge-large-en-v1.5\",\n            ],\n        ],\n        \"Jina AI\": [\n            \"jinaAI\",\n            [\n                \"jina-embeddings-v2-base-en\",\n                \"jina-embeddings-v2-base-de\",\n                \"jina-embeddings-v2-base-es\",\n                \"jina-embeddings-v2-base-code\",\n                \"jina-embeddings-v2-base-zh\",\n            ],\n        ],\n        \"Mistral AI\": [\"mistral\", [\"mistral-embed\"]],\n        \"NVIDIA\": [\"nvidia\", [\"NV-Embed-QA\"]],\n        \"OpenAI\": [\"openai\", [\"text-embedding-3-small\", \"text-embedding-3-large\", \"text-embedding-ada-002\"]],\n        \"Upstage\": [\"upstageAI\", [\"solar-embedding-1-large\"]],\n        \"Voyage AI\": [\n            \"voyageAI\",\n            [\"voyage-large-2-instruct\", \"voyage-law-2\", \"voyage-code-2\", \"voyage-large-2\", \"voyage-2\"],\n        ],\n    }\n    VECTORIZE_MODELS_STR = \"\\n\\n\".join(\n        [provider + \": \" + (\", \".join(models[1])) for provider, models in VECTORIZE_PROVIDERS_MAPPING.items()]\n    )\n\n    inputs = [\n        DropdownInput(\n            name=\"provider\",\n            display_name=\"Provider\",\n            options=VECTORIZE_PROVIDERS_MAPPING.keys(),\n            value=\"\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            info=\"The embedding model to use for the selected provider. Each provider has a different set of models \"\n            f\"available (full list at https://docs.datastax.com/en/astra-db-serverless/databases/embedding-generation.html):\\n\\n{VECTORIZE_MODELS_STR}\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"api_key_name\",\n            display_name=\"API Key name\",\n            info=\"The name of the embeddings provider API key stored on Astra. \"\n            \"If set, it will override the 'ProviderKey' in the authentication parameters.\",\n        ),\n        DictInput(\n            name=\"authentication\",\n            display_name=\"Authentication parameters\",\n            is_list=True,\n            advanced=True,\n        ),\n        SecretStrInput(\n            name=\"provider_api_key\",\n            display_name=\"Provider API Key\",\n            info=\"An alternative to the Astra Authentication that passes an API key for the provider with each request \"\n            \"to Astra DB. \"\n            \"This may be used when Vectorize is configured for the collection, \"\n            \"but no corresponding provider secret is stored within Astra's key management system.\",\n            advanced=True,\n        ),\n        DictInput(\n            name=\"authentication\",\n            display_name=\"Authentication Parameters\",\n            is_list=True,\n            advanced=True,\n        ),\n        DictInput(\n            name=\"model_parameters\",\n            display_name=\"Model Parameters\",\n            advanced=True,\n            is_list=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Vectorize\", name=\"config\", method=\"build_options\", types=[\"dict\"]),\n    ]\n\n    def build_options(self) -> dict[str, Any]:\n        provider_value = self.VECTORIZE_PROVIDERS_MAPPING[self.provider][0]\n        authentication = {**(self.authentication or {})}\n        api_key_name = self.api_key_name\n        if api_key_name:\n            authentication[\"providerKey\"] = api_key_name\n        return {\n            # must match astrapy.info.CollectionVectorServiceOptions\n            \"collection_vector_service_options\": {\n                \"provider\": provider_value,\n                \"modelName\": self.model_name,\n                \"authentication\": authentication,\n                \"parameters\": self.model_parameters or {},\n            },\n            \"collection_embedding_api_key\": self.provider_api_key,\n        }\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "model_name": {
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": true,
                "placeholder": "",
                "show": true,
                "name": "model_name",
                "value": "text-embedding-3-large",
                "display_name": "Model Name",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The embedding model to use for the selected provider. Each provider has a different set of models available (full list at https://docs.datastax.com/en/astra-db-serverless/databases/embedding-generation.html):\n\nAzure OpenAI: text-embedding-3-small, text-embedding-3-large, text-embedding-ada-002\n\nHugging Face - Dedicated: endpoint-defined-model\n\nHugging Face - Serverless: sentence-transformers/all-MiniLM-L6-v2, intfloat/multilingual-e5-large, intfloat/multilingual-e5-large-instruct, BAAI/bge-small-en-v1.5, BAAI/bge-base-en-v1.5, BAAI/bge-large-en-v1.5\n\nJina AI: jina-embeddings-v2-base-en, jina-embeddings-v2-base-de, jina-embeddings-v2-base-es, jina-embeddings-v2-base-code, jina-embeddings-v2-base-zh\n\nMistral AI: mistral-embed\n\nNVIDIA: NV-Embed-QA\n\nOpenAI: text-embedding-3-small, text-embedding-3-large, text-embedding-ada-002\n\nUpstage: solar-embedding-1-large\n\nVoyage AI: voyage-large-2-instruct, voyage-law-2, voyage-code-2, voyage-large-2, voyage-2",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "model_parameters": {
                "trace_as_input": true,
                "list": true,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "model_parameters",
                "value": {},
                "display_name": "Model Parameters",
                "advanced": true,
                "dynamic": false,
                "info": "",
                "title_case": false,
                "type": "dict",
                "_input_type": "DictInput"
              },
              "provider": {
                "tool_mode": false,
                "trace_as_metadata": true,
                "options": [
                  "Azure OpenAI",
                  "Hugging Face - Dedicated",
                  "Hugging Face - Serverless",
                  "Jina AI",
                  "Mistral AI",
                  "NVIDIA",
                  "OpenAI",
                  "Upstage",
                  "Voyage AI"
                ],
                "combobox": false,
                "required": true,
                "placeholder": "",
                "show": true,
                "name": "provider",
                "value": "OpenAI",
                "display_name": "Provider",
                "advanced": false,
                "dynamic": false,
                "info": "",
                "title_case": false,
                "type": "str",
                "_input_type": "DropdownInput"
              },
              "provider_api_key": {
                "load_from_db": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "provider_api_key",
                "value": "",
                "display_name": "Provider API Key",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "An alternative to the Astra Authentication that passes an API key for the provider with each request to Astra DB. This may be used when Vectorize is configured for the collection, but no corresponding provider secret is stored within Astra's key management system.",
                "title_case": false,
                "password": true,
                "type": "str",
                "_input_type": "SecretStrInput"
              }
            },
            "description": "Configuration options for Astra Vectorize server-side embeddings. This component is deprecated. Please use the Astra DB Component directly.",
            "icon": "AstraDB",
            "base_classes": [
              "dict"
            ],
            "display_name": "Astra Vectorize [DEPRECATED]",
            "documentation": "https://docs.datastax.com/en/astra-db-serverless/databases/embedding-generation.html",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": true,
            "outputs": [
              {
                "types": [
                  "dict"
                ],
                "selected": "dict",
                "name": "config",
                "display_name": "Vectorize",
                "method": "build_options",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "provider",
              "model_name",
              "api_key_name",
              "authentication",
              "provider_api_key",
              "authentication",
              "model_parameters"
            ],
            "beta": false,
            "legacy": false,
            "edited": false,
            "metadata": {},
            "tool_mode": false,
            "category": "embeddings",
            "key": "AstraVectorize",
            "score": 0.1972392177586917,
            "lf_version": "1.1.1"
          },
          "type": "AstraVectorize",
          "id": "AstraVectorize-TQ0Iz"
        },
        "selected": false,
        "width": 320,
        "height": 469,
        "positionAbsolute": {
          "x": 1327.12628065442,
          "y": 594.6723848582672
        },
        "dragging": false
      }
    ],
    "edges": [
      {
        "source": "ParseData-obnZv",
        "target": "TextOutput-xfM5I",
        "sourceHandle": "{dataType:ParseData,id:ParseData-obnZv,name:text,output_types:[Message]}",
        "targetHandle": "{fieldName:input_value,id:TextOutput-xfM5I,inputTypes:[Message],type:str}",
        "id": "reactflow__edge-ParseData-obnZv{dataType:ParseData,id:ParseData-obnZv,name:text,output_types:[Message]}-TextOutput-xfM5I{fieldName:input_value,id:TextOutput-xfM5I,inputTypes:[Message],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "input_value",
            "id": "TextOutput-xfM5I",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "ParseData",
            "id": "ParseData-obnZv",
            "name": "text",
            "output_types": [
              "Message"
            ]
          }
        },
        "selected": false,
        "className": "",
        "animated": false
      },
      {
        "source": "AstraDB-wNHGZ",
        "target": "ParseJSONData-eeEA0",
        "sourceHandle": "{dataType:AstraDB,id:AstraDB-wNHGZ,name:search_results,output_types:[Data]}",
        "targetHandle": "{fieldName:input_value,id:ParseJSONData-eeEA0,inputTypes:[Message,Data],type:other}",
        "id": "reactflow__edge-AstraDB-wNHGZ{dataType:AstraDB,id:AstraDB-wNHGZ,name:search_results,output_types:[Data]}-ParseJSONData-eeEA0{fieldName:input_value,id:ParseJSONData-eeEA0,inputTypes:[Message,Data],type:other}",
        "data": {
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ParseJSONData-eeEA0",
            "inputTypes": [
              "Message",
              "Data"
            ],
            "type": "other"
          },
          "sourceHandle": {
            "dataType": "AstraDB",
            "id": "AstraDB-wNHGZ",
            "name": "search_results",
            "output_types": [
              "Data"
            ]
          }
        },
        "selected": false,
        "className": "",
        "animated": false
      },
      {
        "source": "ParseJSONData-eeEA0",
        "target": "ParseData-obnZv",
        "sourceHandle": "{dataType:ParseJSONData,id:ParseJSONData-eeEA0,name:filtered_data,output_types:[Data]}",
        "targetHandle": "{fieldName:data,id:ParseData-obnZv,inputTypes:[Data],type:other}",
        "id": "reactflow__edge-ParseJSONData-eeEA0{dataType:ParseJSONData,id:ParseJSONData-eeEA0,name:filtered_data,output_types:[Data]}-ParseData-obnZv{fieldName:data,id:ParseData-obnZv,inputTypes:[Data],type:other}",
        "data": {
          "targetHandle": {
            "fieldName": "data",
            "id": "ParseData-obnZv",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          },
          "sourceHandle": {
            "dataType": "ParseJSONData",
            "id": "ParseJSONData-eeEA0",
            "name": "filtered_data",
            "output_types": [
              "Data"
            ]
          }
        },
        "selected": false,
        "className": "",
        "animated": false
      },
      {
        "source": "TextInput-n0QkP",
        "target": "MetaDataFilterConstructor-vAJyP",
        "sourceHandle": "{dataType:TextInput,id:TextInput-n0QkP,name:text,output_types:[Message]}",
        "targetHandle": "{fieldName:tribe,id:MetaDataFilterConstructor-vAJyP,inputTypes:[Message],type:str}",
        "id": "reactflow__edge-TextInput-n0QkP{dataType:TextInput,id:TextInput-n0QkP,name:text,output_types:[Message]}-MetaDataFilterConstructor-vAJyP{fieldName:tribe,id:MetaDataFilterConstructor-vAJyP,inputTypes:[Message],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "tribe",
            "id": "MetaDataFilterConstructor-vAJyP",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-n0QkP",
            "name": "text",
            "output_types": [
              "Message"
            ]
          }
        },
        "selected": false,
        "className": "",
        "animated": false
      },
      {
        "source": "TextInput-P1BmY",
        "target": "MetaDataFilterConstructor-vAJyP",
        "sourceHandle": "{dataType:TextInput,id:TextInput-P1BmY,name:text,output_types:[Message]}",
        "targetHandle": "{fieldName:likes_minimum,id:MetaDataFilterConstructor-vAJyP,inputTypes:[Message],type:str}",
        "id": "reactflow__edge-TextInput-P1BmY{dataType:TextInput,id:TextInput-P1BmY,name:text,output_types:[Message]}-MetaDataFilterConstructor-vAJyP{fieldName:likes_minimum,id:MetaDataFilterConstructor-vAJyP,inputTypes:[Message],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "likes_minimum",
            "id": "MetaDataFilterConstructor-vAJyP",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-P1BmY",
            "name": "text",
            "output_types": [
              "Message"
            ]
          }
        },
        "selected": false,
        "className": "",
        "animated": false
      },
      {
        "source": "MetaDataFilterConstructor-vAJyP",
        "target": "AstraDB-wNHGZ",
        "sourceHandle": "{dataType:MetaDataFilterConstructor,id:MetaDataFilterConstructor-vAJyP,name:result,output_types:[Message]}",
        "targetHandle": "{fieldName:search_filter,id:AstraDB-wNHGZ,inputTypes:[Message],type:str}",
        "id": "reactflow__edge-MetaDataFilterConstructor-vAJyP{dataType:MetaDataFilterConstructor,id:MetaDataFilterConstructor-vAJyP,name:result,output_types:[Message]}-AstraDB-wNHGZ{fieldName:search_filter,id:AstraDB-wNHGZ,inputTypes:[Message],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "search_filter",
            "id": "AstraDB-wNHGZ",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "MetaDataFilterConstructor",
            "id": "MetaDataFilterConstructor-vAJyP",
            "name": "result",
            "output_types": [
              "Message"
            ]
          }
        },
        "selected": false,
        "className": "",
        "animated": false
      },
      {
        "source": "TextInput-Uk4ri",
        "target": "MetaDataFilterConstructor-vAJyP",
        "sourceHandle": "{dataType:TextInput,id:TextInput-Uk4ri,name:text,output_types:[Message]}",
        "targetHandle": "{fieldName:datetime_from,id:MetaDataFilterConstructor-vAJyP,inputTypes:[Message],type:str}",
        "id": "reactflow__edge-TextInput-Uk4ri{dataType:TextInput,id:TextInput-Uk4ri,name:text,output_types:[Message]}-MetaDataFilterConstructor-vAJyP{fieldName:datetime_from,id:MetaDataFilterConstructor-vAJyP,inputTypes:[Message],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "datetime_from",
            "id": "MetaDataFilterConstructor-vAJyP",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-Uk4ri",
            "name": "text",
            "output_types": [
              "Message"
            ]
          }
        },
        "selected": false,
        "className": "",
        "animated": false
      },
      {
        "source": "TextInput-aYfSJ",
        "target": "MetaDataFilterConstructor-vAJyP",
        "sourceHandle": "{dataType:TextInput,id:TextInput-aYfSJ,name:text,output_types:[Message]}",
        "targetHandle": "{fieldName:platform,id:MetaDataFilterConstructor-vAJyP,inputTypes:[Message],type:str}",
        "id": "reactflow__edge-TextInput-aYfSJ{dataType:TextInput,id:TextInput-aYfSJ,name:text,output_types:[Message]}-MetaDataFilterConstructor-vAJyP{fieldName:platform,id:MetaDataFilterConstructor-vAJyP,inputTypes:[Message],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "platform",
            "id": "MetaDataFilterConstructor-vAJyP",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-aYfSJ",
            "name": "text",
            "output_types": [
              "Message"
            ]
          }
        },
        "selected": false,
        "className": "",
        "animated": false
      },
      {
        "source": "TextInput-wg8O0",
        "target": "MetaDataFilterConstructor-vAJyP",
        "sourceHandle": "{dataType:TextInput,id:TextInput-wg8O0,name:text,output_types:[Message]}",
        "targetHandle": "{fieldName:country,id:MetaDataFilterConstructor-vAJyP,inputTypes:[Message],type:str}",
        "id": "reactflow__edge-TextInput-wg8O0{dataType:TextInput,id:TextInput-wg8O0,name:text,output_types:[Message]}-MetaDataFilterConstructor-vAJyP{fieldName:country,id:MetaDataFilterConstructor-vAJyP,inputTypes:[Message],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "country",
            "id": "MetaDataFilterConstructor-vAJyP",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-wg8O0",
            "name": "text",
            "output_types": [
              "Message"
            ]
          }
        },
        "selected": false,
        "className": "",
        "animated": false
      },
      {
        "source": "TextInput-WCBMY",
        "target": "MetaDataFilterConstructor-vAJyP",
        "sourceHandle": "{dataType:TextInput,id:TextInput-WCBMY,name:text,output_types:[Message]}",
        "targetHandle": "{fieldName:gender,id:MetaDataFilterConstructor-vAJyP,inputTypes:[Message],type:str}",
        "id": "reactflow__edge-TextInput-WCBMY{dataType:TextInput,id:TextInput-WCBMY,name:text,output_types:[Message]}-MetaDataFilterConstructor-vAJyP{fieldName:gender,id:MetaDataFilterConstructor-vAJyP,inputTypes:[Message],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "gender",
            "id": "MetaDataFilterConstructor-vAJyP",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-WCBMY",
            "name": "text",
            "output_types": [
              "Message"
            ]
          }
        },
        "selected": false,
        "className": "",
        "animated": false
      },
      {
        "source": "ParseData-obnZv",
        "target": "Prompt-oU1Ym",
        "sourceHandle": "{dataType:ParseData,id:ParseData-obnZv,name:text,output_types:[Message]}",
        "targetHandle": "{fieldName:context,id:Prompt-oU1Ym,inputTypes:[Message,Text],type:str}",
        "id": "reactflow__edge-ParseData-obnZv{dataType:ParseData,id:ParseData-obnZv,name:text,output_types:[Message]}-Prompt-oU1Ym{fieldName:context,id:Prompt-oU1Ym,inputTypes:[Message,Text],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "context",
            "id": "Prompt-oU1Ym",
            "inputTypes": [
              "Message",
              "Text"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "ParseData",
            "id": "ParseData-obnZv",
            "name": "text",
            "output_types": [
              "Message"
            ]
          }
        },
        "selected": false,
        "className": "",
        "animated": false
      },
      {
        "source": "ChatInput-nM66I",
        "target": "Prompt-oU1Ym",
        "sourceHandle": "{dataType:ChatInput,id:ChatInput-nM66I,name:message,output_types:[Message]}",
        "targetHandle": "{fieldName:question,id:Prompt-oU1Ym,inputTypes:[Message,Text],type:str}",
        "id": "reactflow__edge-ChatInput-nM66I{dataType:ChatInput,id:ChatInput-nM66I,name:message,output_types:[Message]}-Prompt-oU1Ym{fieldName:question,id:Prompt-oU1Ym,inputTypes:[Message,Text],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "question",
            "id": "Prompt-oU1Ym",
            "inputTypes": [
              "Message",
              "Text"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "ChatInput",
            "id": "ChatInput-nM66I",
            "name": "message",
            "output_types": [
              "Message"
            ]
          }
        },
        "selected": false,
        "className": "",
        "animated": false
      },
      {
        "source": "TextInput-UhThw",
        "target": "MetaDataFilterConstructor-vAJyP",
        "sourceHandle": "{dataType:TextInput,id:TextInput-UhThw,name:text,output_types:[Message]}",
        "targetHandle": "{fieldName:followers,id:MetaDataFilterConstructor-vAJyP,inputTypes:[Message],type:str}",
        "id": "reactflow__edge-TextInput-UhThw{dataType:TextInput,id:TextInput-UhThw,name:text,output_types:[Message]}-MetaDataFilterConstructor-vAJyP{fieldName:followers,id:MetaDataFilterConstructor-vAJyP,inputTypes:[Message],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "followers",
            "id": "MetaDataFilterConstructor-vAJyP",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-UhThw",
            "name": "text",
            "output_types": [
              "Message"
            ]
          }
        },
        "selected": false,
        "className": "",
        "animated": false
      },
      {
        "source": "TextInput-4wKnt",
        "target": "MetaDataFilterConstructor-vAJyP",
        "sourceHandle": "{dataType:TextInput,id:TextInput-4wKnt,name:text,output_types:[Message]}",
        "targetHandle": "{fieldName:age,id:MetaDataFilterConstructor-vAJyP,inputTypes:[Message],type:str}",
        "id": "reactflow__edge-TextInput-4wKnt{dataType:TextInput,id:TextInput-4wKnt,name:text,output_types:[Message]}-MetaDataFilterConstructor-vAJyP{fieldName:age,id:MetaDataFilterConstructor-vAJyP,inputTypes:[Message],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "age",
            "id": "MetaDataFilterConstructor-vAJyP",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-4wKnt",
            "name": "text",
            "output_types": [
              "Message"
            ]
          }
        },
        "selected": false,
        "className": "",
        "animated": false
      },
      {
        "source": "Memory-MeAfJ",
        "target": "Prompt-oU1Ym",
        "sourceHandle": "{dataType:Memory,id:Memory-MeAfJ,name:messages_text,output_types:[Message]}",
        "targetHandle": "{fieldName:history,id:Prompt-oU1Ym,inputTypes:[Message,Text],type:str}",
        "id": "reactflow__edge-Memory-MeAfJ{dataType:Memory,id:Memory-MeAfJ,name:messages_text,output_types:[Message]}-Prompt-oU1Ym{fieldName:history,id:Prompt-oU1Ym,inputTypes:[Message,Text],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "history",
            "id": "Prompt-oU1Ym",
            "inputTypes": [
              "Message",
              "Text"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "Memory",
            "id": "Memory-MeAfJ",
            "name": "messages_text",
            "output_types": [
              "Message"
            ]
          }
        },
        "selected": false,
        "className": "",
        "animated": false
      },
      {
        "source": "TextInput-JZobh",
        "target": "AstraDB-wNHGZ",
        "sourceHandle": "{dataType:TextInput,id:TextInput-JZobh,name:text,output_types:[Message]}",
        "targetHandle": "{fieldName:search_input,id:AstraDB-wNHGZ,inputTypes:[Message],type:str}",
        "id": "reactflow__edge-TextInput-JZobh{dataType:TextInput,id:TextInput-JZobh,name:text,output_types:[Message]}-AstraDB-wNHGZ{fieldName:search_input,id:AstraDB-wNHGZ,inputTypes:[Message],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "search_input",
            "id": "AstraDB-wNHGZ",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-JZobh",
            "name": "text",
            "output_types": [
              "Message"
            ]
          }
        },
        "selected": false,
        "className": "",
        "animated": false
      },
      {
        "source": "Prompt-oU1Ym",
        "target": "OpenAIModel-wA6hw",
        "sourceHandle": "{dataType:Prompt,id:Prompt-oU1Ym,name:prompt,output_types:[Message]}",
        "targetHandle": "{fieldName:input_value,id:OpenAIModel-wA6hw,inputTypes:[Message],type:str}",
        "id": "reactflow__edge-Prompt-oU1Ym{dataType:Prompt,id:Prompt-oU1Ym,name:prompt,output_types:[Message]}-OpenAIModel-wA6hw{fieldName:input_value,id:OpenAIModel-wA6hw,inputTypes:[Message],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "input_value",
            "id": "OpenAIModel-wA6hw",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "Prompt",
            "id": "Prompt-oU1Ym",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          }
        },
        "selected": false,
        "className": "",
        "animated": false
      },
      {
        "source": "AstraVectorize-TQ0Iz",
        "sourceHandle": "{dataType:AstraVectorize,id:AstraVectorize-TQ0Iz,name:config,output_types:[dict]}",
        "target": "AstraDB-wNHGZ",
        "targetHandle": "{fieldName:embedding,id:AstraDB-wNHGZ,inputTypes:[Embeddings,dict],type:other}",
        "data": {
          "targetHandle": {
            "fieldName": "embedding",
            "id": "AstraDB-wNHGZ",
            "inputTypes": [
              "Embeddings",
              "dict"
            ],
            "type": "other"
          },
          "sourceHandle": {
            "dataType": "AstraVectorize",
            "id": "AstraVectorize-TQ0Iz",
            "name": "config",
            "output_types": [
              "dict"
            ]
          }
        },
        "id": "reactflow__edge-AstraVectorize-TQ0Iz{dataType:AstraVectorize,id:AstraVectorize-TQ0Iz,name:config,output_types:[dict]}-AstraDB-wNHGZ{fieldName:embedding,id:AstraDB-wNHGZ,inputTypes:[Embeddings,dict],type:other}",
        "animated": false,
        "className": ""
      },
      {
        "source": "Prompt-oU1Ym",
        "sourceHandle": "{dataType:Prompt,id:Prompt-oU1Ym,name:prompt,output_types:[Message]}",
        "target": "AnthropicModel-FvFsG",
        "targetHandle": "{fieldName:input_value,id:AnthropicModel-FvFsG,inputTypes:[Message],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "input_value",
            "id": "AnthropicModel-FvFsG",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "Prompt",
            "id": "Prompt-oU1Ym",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          }
        },
        "id": "reactflow__edge-Prompt-oU1Ym{dataType:Prompt,id:Prompt-oU1Ym,name:prompt,output_types:[Message]}-AnthropicModel-FvFsG{fieldName:input_value,id:AnthropicModel-FvFsG,inputTypes:[Message],type:str}",
        "className": "",
        "animated": false
      },
      {
        "source": "AnthropicModel-FvFsG",
        "sourceHandle": "{dataType:AnthropicModel,id:AnthropicModel-FvFsG,name:text_output,output_types:[Message]}",
        "target": "CombineText-88DLO",
        "targetHandle": "{fieldName:text1,id:CombineText-88DLO,inputTypes:[Message],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "text1",
            "id": "CombineText-88DLO",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "AnthropicModel",
            "id": "AnthropicModel-FvFsG",
            "name": "text_output",
            "output_types": [
              "Message"
            ]
          }
        },
        "id": "reactflow__edge-AnthropicModel-FvFsG{dataType:AnthropicModel,id:AnthropicModel-FvFsG,name:text_output,output_types:[Message]}-CombineText-88DLO{fieldName:text1,id:CombineText-88DLO,inputTypes:[Message],type:str}",
        "className": "",
        "animated": false
      },
      {
        "source": "OpenAIModel-wA6hw",
        "sourceHandle": "{dataType:OpenAIModel,id:OpenAIModel-wA6hw,name:text_output,output_types:[Message]}",
        "target": "CombineText-88DLO",
        "targetHandle": "{fieldName:text2,id:CombineText-88DLO,inputTypes:[Message],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "text2",
            "id": "CombineText-88DLO",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "OpenAIModel",
            "id": "OpenAIModel-wA6hw",
            "name": "text_output",
            "output_types": [
              "Message"
            ]
          }
        },
        "id": "reactflow__edge-OpenAIModel-wA6hw{dataType:OpenAIModel,id:OpenAIModel-wA6hw,name:text_output,output_types:[Message]}-CombineText-88DLO{fieldName:text2,id:CombineText-88DLO,inputTypes:[Message],type:str}",
        "className": "",
        "animated": false
      },
      {
        "source": "CombineText-88DLO",
        "sourceHandle": "{dataType:CombineText,id:CombineText-88DLO,name:combined_text,output_types:[Message]}",
        "target": "ChatOutput-plpD3",
        "targetHandle": "{fieldName:input_value,id:ChatOutput-plpD3,inputTypes:[Message],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-plpD3",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "CombineText",
            "id": "CombineText-88DLO",
            "name": "combined_text",
            "output_types": [
              "Message"
            ]
          }
        },
        "id": "reactflow__edge-CombineText-88DLO{dataType:CombineText,id:CombineText-88DLO,name:combined_text,output_types:[Message]}-ChatOutput-plpD3{fieldName:input_value,id:ChatOutput-plpD3,inputTypes:[Message],type:str}",
        "className": "",
        "animated": false
      }
    ],
    "viewport": {
      "x": 39.873354247814405,
      "y": 208.61101009076066,
      "zoom": 0.15860501488201012
    }
  },
  "is_component": false,
  "updated_at": "2025-01-16T20:30:39+00:00",
  "icon": null,
  "name": "TRIBE for Climate Convos",
  "icon_bg_color": null,
  "webhook": false,
  "user_id": "93a8d8ca-0bf4-4646-8602-7c7f969adb63",
  "description": "Global Briefs Climate Change RAG Store"
}